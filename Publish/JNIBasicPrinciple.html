<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
               "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"
lang="en" xml:lang="en">
<head>
<title>JNI与NDK</title>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
<meta name="generator" content="Org-mode"/>
<meta name="generated" content="2012-08-01 11:05:22 CST"/>
<meta name="author" content="Wizard.Yang"/>
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  html { font-family: Times, serif; font-size: 12pt; }
  .title  { text-align: center; }
  .todo   { color: red; }
  .done   { color: green; }
  .tag    { background-color:lightblue; font-weight:normal }
  .target { }
  .timestamp { color: grey }
  .timestamp-kwd { color: CadetBlue }
  p.verse { margin-left: 3% }
  pre {
	border: 1pt solid #AEBDCC;
	background-color: #F3F5F7;
	padding: 5pt;
	font-family: courier, monospace;
        font-size: 90%;
        overflow:auto;
  }
  table { border-collapse: collapse; }
  td, th { vertical-align: top; }
  dt { font-weight: bold; }
  div.figure { padding: 0.5em; }
  div.figure p { text-align: center; }
  .linenr { font-size:smaller }
  .code-highlighted {background-color:#ffff00;}
  .org-info-js_info-navigation { border-style:none; }
  #org-info-js_console-label { font-size:10px; font-weight:bold;
                               white-space:nowrap; }
  .org-info-js_search-highlight {background-color:#ffff00; color:#000000;
                                 font-weight:bold; }
  /*]]>*/-->
</style>
<script type="text/javascript">
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*/-->
</script>
</head><body>
<h1 class="title">JNI与NDK</h1>

<p>参考《Android框架揭秘》
</p>

<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1 JNI的基本原理 </a>
<ul>
<li><a href="#sec-1.1">1.1 在Java中调用C库函数 </a>
<ul>
<li><a href="#sec-1.1.1">1.1.1 第一步 编写Java代码 </a></li>
<li><a href="#sec-1.1.2">1.1.2 第二步 编译Java代码 </a></li>
<li><a href="#sec-1.1.3">1.1.3 第三步 生成C语言头文件 </a></li>
<li><a href="#sec-1.1.4">1.1.4 第四步 编写C/C++代码 </a></li>
<li><a href="#sec-1.1.5">1.1.5 第五步 生成C共享库 </a></li>
<li><a href="#sec-1.1.6">1.1.6 第六步 运行Java程序 </a></li>
</ul>
</li>
<li><a href="#sec-1.2">1.2 小结 </a></li>
</ul>
</li>
<li><a href="#sec-2">2 调用JNI函数 </a>
<ul>
<li><a href="#sec-2.1">2.1 调用JNI函数的示例程序结构 </a></li>
<li><a href="#sec-2.2">2.2 Java层代码 (JniFuncMain.java) </a></li>
<li><a href="#sec-2.3">2.3 分析JNI本地函数代码 </a>
<ul>
<li>
<ul>
<li><a href="#sec-2.3.1">2.3.1 JniFuncMain.h头文件 </a></li>
<li><a href="#sec-2.3.2">2.3.2 jnifunc.cpp 文件 </a></li>
<li><a href="#sec-2.3.3">2.3.3 通过JNI,获取成员变量值 </a></li>
<li><a href="#sec-2.3.4">2.3.4 调用Java方法 </a></li>
<li><a href="#sec-2.3.5">2.3.5 通过JNI设置成员变量的值 </a></li>
</ul></li>
</ul></li>
</ul>
</li>
<li><a href="#sec-3">3 在C程序中运行Java类 </a>
<ul>
<li><a href="#sec-3.1">3.1 Invocaton API 应用示例 </a>
<ul>
<li><a href="#sec-3.1.1">3.1.1 分析Java代码 InvocationApiTest.java </a></li>
<li><a href="#sec-3.1.2">3.1.2 分析C代码 invocationApi.c </a></li>
</ul></li>
</ul>
</li>
<li><a href="#sec-4">4 直接注册JNI本地函数 </a>
<ul>
<li><a href="#sec-4.1">4.1 加载本地库时，注册JNI本地函数 </a></li>
<li><a href="#sec-4.2">4.2 Android中的应用举例 </a></li>
</ul>
</li>
<li><a href="#sec-5">5 使用Android NDK开发 </a>
<ul>
<li><a href="#sec-5.1">5.1 安装Androdi NDK </a></li>
<li><a href="#sec-5.2">5.2 使用Android NDK 开发步骤 </a></li>
<li><a href="#sec-5.3">5.3 hello-jni </a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-1" class="outline-2">
<h2 id="sec-1">1 JNI的基本原理 </h2>
<div id="text-1">



</div>

<div id="outline-container-1.1" class="outline-3">
<h3 id="sec-1.1">1.1 在Java中调用C库函数 </h3>
<div id="text-1.1">


<p>
开发流程

</p>
<hr/>
<p>
在Java代码中通过JNI调用C函数的步骤如下：
</p>
<p>
第一步： 编写Java代码
</p>
<p>
第二步： 编译Java代码
</p>
<p>
第三步: 生成C语言头文件
</p>
<p>
第四步： 编写C代码
</p>
<p>
第五步： 生成C共享库
</p>
<p>
第六步： 运行Java程序
</p>

</div>

<div id="outline-container-1.1.1" class="outline-4">
<h4 id="sec-1.1.1">1.1.1 第一步 编写Java代码 </h4>
<div id="text-1.1.1">


<p>
JNI方法是在Java代码中声明的。
</p>
<p>
在Java类中，使用"native"关键字，声明本地方法该方法与用C/C++编写的JNI本地函数相对应。"native"关键字告知Java编译器，在Java代码中带有该关键字的方法只是声明，具体由C/C++等其他语言编写实现。
</p>
<p>
如果起吊方法前的native关键字，编译代码时，Java编译器就会报错，抛出编译错误，告知该方法没有实现。
</p>
<p>
调用System.loadLibrary()方法加载具体的实现本地方法的C运行库。System.loadLibrary()方法加载由字符串参数指定的本地库，在不同操作系统平台下，加载的C运行库不同。
</p>
</div>

</div>

<div id="outline-container-1.1.2" class="outline-4">
<h4 id="sec-1.1.2">1.1.2 第二步 编译Java代码 </h4>
<div id="text-1.1.2">





<pre class="src src-java">
<span style="color: #9acd32; font-weight: bold;">javac</span> xxx.<span style="color: #add8e6; font-weight: bold; font-style: italic;">java</span>
</pre>




<p>
生成 xxx.class
</p>
</div>

</div>

<div id="outline-container-1.1.3" class="outline-4">
<h4 id="sec-1.1.3">1.1.3 第三步 生成C语言头文件 </h4>
<div id="text-1.1.3">





<pre class="src src-java">
javah -classpath path classname
</pre>




<p>
生成classname.h
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<col align="left"></col><colgroup><col align="left"></col>
</colgroup>
<thead>
<tr><th>Java类型</th><th>Java本地类型</th></tr>
</thead>
<tbody>
</tbody>
<tbody>
<tr><td>byte</td><td>jbyte</td></tr>
<tr><td>short</td><td>jshort</td></tr>
<tr><td>int</td><td>jint</td></tr>
<tr><td>long</td><td>jlong</td></tr>
<tr><td>float</td><td>jfloat</td></tr>
<tr><td>double</td><td>jdouble</td></tr>
<tr><td>char</td><td>jchar</td></tr>
<tr><td>boolean</td><td>jboolean</td></tr>
<tr><td>void</td><td>void</td></tr>
</tbody>
</table>


<p>
Java本地类型也提供了另外三种类型
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<col align="left"></col><colgroup><col align="left"></col>
</colgroup>
<thead>
<tr><th>java引用类型</th><th>java本地类型</th></tr>
</thead>
<tbody>
</tbody>
<tbody>
<tr><td>对象</td><td>Jobject</td></tr>
<tr><td>String</td><td>Jstring</td></tr>
</tbody>
</table>


</div>

</div>

<div id="outline-container-1.1.4" class="outline-4">
<h4 id="sec-1.1.4">1.1.4 第四步 编写C/C++代码 </h4>
<div id="text-1.1.4">


<p>
编写xxx.c文件
</p>
</div>

</div>

<div id="outline-container-1.1.5" class="outline-4">
<h4 id="sec-1.1.5">1.1.5 第五步 生成C共享库 </h4>
<div id="text-1.1.5">





<pre class="src src-sh">
cc -I/usr/lib/jvm/java-6-sun/include/linux
   -I/usr/lib/jvm/java-6-sun/include/
   -fPIC -shared -o libxxx.so xxx.c
</pre>




</div>

</div>

<div id="outline-container-1.1.6" class="outline-4">
<h4 id="sec-1.1.6">1.1.6 第六步 运行Java程序 </h4>
<div id="text-1.1.6">





<pre class="src src-java">
java -cp path -o java.library.path=<span style="color: #8fbc8f; font-style: italic;">'path'</span> classname
</pre>




</div>
</div>

</div>

<div id="outline-container-1.2" class="outline-3">
<h3 id="sec-1.2">1.2 小结 </h3>
<div id="text-1.2">


<p>
（1）在java类中声明本地方法
</p>
<p>
（2）使用javah命令，生成包含JNI本地函数原型的头文件
</p>
<p>
（3）实现JNI本地函数
</p>
<p>
（4）生成C共享库
</p>
<p>
（5）通过JNI，调用JNI本地函数
</p>
</div>
</div>

</div>

<div id="outline-container-2" class="outline-2">
<h2 id="sec-2">2 调用JNI函数 </h2>
<div id="text-2">


<p>
在由C语言编写的JNI本地函数中如何控制Java端的代码
</p>
<ul>
<li>
创建Java对象

</li>
<li>
访问静态成员域

</li>
<li>
调用类的静态方法

</li>
<li>
访问Java对象的成员变量

</li>
<li>
访问Java对象的方法

</li>
</ul>

</div>

<div id="outline-container-2.1" class="outline-3">
<h3 id="sec-2.1">2.1 调用JNI函数的示例程序结构 </h3>
<div id="text-2.1">


</div>

</div>

<div id="outline-container-2.2" class="outline-3">
<h3 id="sec-2.2">2.2 Java层代码 (JniFuncMain.java) </h3>
<div id="text-2.2">


<p>
1.JniFuncMain类
</p>


<pre class="src src-java">
<span style="color: #add8e6; font-weight: bold;">public</span> <span style="color: #add8e6; font-weight: bold;">class</span> <span style="color: #9acd32; font-weight: bold;">JniFuncMain</span>
{
    print <span style="color: #add8e6; font-weight: bold;">static</span> <span style="color: #9acd32; font-weight: bold;">int</span> <span style="color: #add8e6; font-weight: bold; font-style: italic;">staticIntField</span> = 300;

    <span style="color: #cccccc; font-style: italic;">// </span><span style="color: #cccccc; font-style: italic;">&#21152;&#36733;&#26412;&#22320;&#24211;
</span>    <span style="color: #add8e6; font-weight: bold;">static</span> { System.loadLibrary(<span style="color: #8fbc8f; font-style: italic;">"jnifunc"</span>); }

    <span style="color: #cccccc; font-style: italic;">// </span><span style="color: #cccccc; font-style: italic;">&#26412;&#22320;&#26041;&#27861;&#22768;&#26126;
</span>
    <span style="color: #add8e6; font-weight: bold;">public</span> <span style="color: #add8e6; font-weight: bold;">static</span> <span style="color: #add8e6; font-weight: bold;">native</span> <span style="color: #9acd32; font-weight: bold;">JniTest</span> <span style="color: #ffff00; font-weight: bold; font-style: italic;">createJniObject</span>();

    <span style="color: #add8e6; font-weight: bold;">public</span> <span style="color: #add8e6; font-weight: bold;">static</span> <span style="color: #9acd32; font-weight: bold;">void</span> <span style="color: #ffff00; font-weight: bold; font-style: italic;">main</span>(<span style="color: #9acd32; font-weight: bold;">String</span>[] <span style="color: #add8e6; font-weight: bold; font-style: italic;">args</span>)
    {
        <span style="color: #cccccc; font-style: italic;">// </span><span style="color: #cccccc; font-style: italic;">&#20174;&#26412;&#22320;&#20195;&#30721;&#29983;&#25104;JniTest&#23545;&#35937;
</span>        System.out.println(<span style="color: #8fbc8f; font-style: italic;">"[Java] createJniObject() &#35843;&#29992;&#26412;&#22320;&#26041;&#27861;"</span>);
        <span style="color: #9acd32; font-weight: bold;">JniTest</span> <span style="color: #add8e6; font-weight: bold; font-style: italic;">jniObj</span> = createJniObject();

        <span style="color: #cccccc; font-style: italic;">// </span><span style="color: #cccccc; font-style: italic;">&#35843;&#29992;JniTest&#23545;&#35937;&#30340;&#26041;&#27861;
</span>        jniObj.callTest();
    }
}
</pre>



<p>
JniFuncMain.java中的JniFuncMain类
</p>
<ul>
<li>
通过java静态块，在调用本地方法前，加载jnifunc运行库

</li>
<li>
使用static关键字声明本地方法createJniObject()在调研那个此方法时不需要创建对象，直接通过JniFuncMain类调用即可

</li>
<li>
不使用Java语言的new运算符，调用与createJniObject()本地方法相对应的C函数生成JniTest类的对象，在将对象的引用保存在jniObj引用变量中

</li>
<li>
调用jniObj对象的callTest()方法

</li>
</ul>

<p>2.JniTest类
</p>



<pre class="src src-java">
<span style="color: #add8e6; font-weight: bold;">class</span> <span style="color: #9acd32; font-weight: bold;">JniTest</span> 
{
    <span style="color: #add8e6; font-weight: bold;">private</span> <span style="color: #9acd32; font-weight: bold;">int</span> <span style="color: #add8e6; font-weight: bold; font-style: italic;">intField</span>;
    <span style="color: #cccccc; font-style: italic;">//</span><span style="color: #cccccc; font-style: italic;">&#26500;&#36896;&#26041;&#27861;
</span>
    <span style="color: #add8e6; font-weight: bold;">public</span> JniTest(<span style="color: #9acd32; font-weight: bold;">int</span> <span style="color: #add8e6; font-weight: bold; font-style: italic;">num</span>)
    {
        intField = num;
        System.out.println(<span style="color: #8fbc8f; font-style: italic;">"[Java] &#35843;&#29992;JniTest&#23545;&#35937;&#30340;&#26500;&#36896;&#26041;&#27861;:intField = "</span> + intField);
    }

    <span style="color: #cccccc; font-style: italic;">// </span><span style="color: #cccccc; font-style: italic;">&#27492;&#26041;&#27861;&#30001;JNI&#26412;&#22320;&#20989;&#25968;&#35843;&#29992;
</span>    <span style="color: #add8e6; font-weight: bold;">public</span> <span style="color: #9acd32; font-weight: bold;">int</span> <span style="color: #ffff00; font-weight: bold; font-style: italic;">callByNative</span>(<span style="color: #9acd32; font-weight: bold;">int</span> <span style="color: #add8e6; font-weight: bold; font-style: italic;">num</span>)
    {
        System.out.println(<span style="color: #8fbc8f; font-style: italic;">"[Java] JniTest &#23545;&#35937;&#30340; callByNative("</span>+ num +<span style="color: #8fbc8f; font-style: italic;">")&#35843;&#29992;"</span>);
        <span style="color: #add8e6; font-weight: bold;">return</span> num;
    }

    <span style="color: #add8e6; font-weight: bold;">public</span> <span style="color: #9acd32; font-weight: bold;">void</span> <span style="color: #ffff00; font-weight: bold; font-style: italic;">callTest</span>() 
    {
        System.out.println(<span style="color: #8fbc8f; font-style: italic;">"[Java] JniTest &#23545;&#35937;&#30340; callTest() &#26041;&#27861;&#35843;&#29992;&#65306;intField="</span>intField<span style="color: #ffa07a; font-weight: bold;">"</span><span style="color: #8fbc8f; font-style: italic;">);
    }
}
</span></pre>




</div>

</div>

<div id="outline-container-2.3" class="outline-3">
<h3 id="sec-2.3">2.3 分析JNI本地函数代码 </h3>
<div id="text-2.3">



</div>

<div id="outline-container-2.3.1" class="outline-5">
<h5 id="sec-2.3.1">2.3.1 JniFuncMain.h头文件 </h5>
<div id="text-2.3.1">


<p>
使用javah命令，生成本地方法的函数原型
</p>


<pre class="src src-java">
<span style="color: #9acd32; font-weight: bold;">javah</span> <span style="color: #add8e6; font-weight: bold; font-style: italic;">JniFuncMain</span>
</pre>



<p>
JniFuncMain.h
</p>


<pre class="src src-c">
<span style="color: #cccccc; font-style: italic;">/* </span><span style="color: #cccccc; font-style: italic;">DO NOT EDIT THIS FILE - it is machine generated </span><span style="color: #cccccc; font-style: italic;">*/</span>
<span style="color: #0000cd;">#include</span> <span style="color: #8fbc8f; font-style: italic;">&lt;jni.h&gt;</span>
<span style="color: #cccccc; font-style: italic;">/* </span><span style="color: #cccccc; font-style: italic;">Header for class JniFuncMain </span><span style="color: #cccccc; font-style: italic;">*/</span>

<span style="color: #0000cd;">#if</span><span style="color: #0000cd;">n</span><span style="color: #0000cd;">def</span> _Included_JniFuncMain
<span style="color: #0000cd;">#define</span> <span style="color: #add8e6; font-weight: bold; font-style: italic;">_Included_JniFuncMain</span>
<span style="color: #0000cd;">#ifdef</span> __cplusplus
<span style="color: #add8e6; font-weight: bold;">extern</span> <span style="color: #8fbc8f; font-style: italic;">"C"</span> {
<span style="color: #0000cd;">#endif</span>
<span style="color: #cccccc; font-style: italic;">/*</span><span style="color: #cccccc; font-style: italic;">
 * Class:     JniFuncMain
 * Method:    createJniObject
 * Signature: ()LJniTest;
 </span><span style="color: #cccccc; font-style: italic;">*/</span>
JNIEXPORT jobject <span style="color: #9acd32; font-weight: bold;">JNICALL</span> <span style="color: #ffff00; font-weight: bold; font-style: italic;">Java_JniFuncMain_CreateJniObject</span>(<span style="color: #9acd32; font-weight: bold;">JNIEnv</span> *, jclass);
<span style="color: #0000cd;">#ifdef</span> __cplusplus
}
<span style="color: #0000cd;">#endif</span>
<span style="color: #0000cd;">#endif</span>
</pre>




<p>
createJniObject()本地方法对应的JNI本地函数原型，形式如下
</p>
<p>
JNIEXPORT jobject JNICALL Java<sub>JniFuncMain</sub><sub>createJniObject</sub>(JNIEnv *, jclass)
</p>
</div>

</div>

<div id="outline-container-2.3.2" class="outline-5">
<h5 id="sec-2.3.2">2.3.2 jnifunc.cpp 文件 </h5>
<div id="text-2.3.2">





<pre class="src src-C++">
JNIEXPORT jobject JNICALL Java_JniFuncMain_createJniObject(JNIEnv *env, jclass clazz)
{
    jclass targetClass;
    jmethodID mid;
    jobject newObject;
    jstring helloStr;
    jfieldID fid;
    jint staticIntField;
    jint result;

    // &#33719;&#21462;JniFuncMain&#31867;&#30340;staticIntField&#21464;&#37327;&#20540;
    fid = env-&gt;GetStaticFieldID(clazz, <span style="color: #8fbc8f; font-style: italic;">"staticIntField"</span>, <span style="color: #8fbc8f; font-style: italic;">"I"</span>);
    staticIntField = env-&gt;GetStaticIntField(clazz, fid);
    printf(<span style="color: #8fbc8f; font-style: italic;">"[CPP] &#33719;&#21462;JniFuncMain&#31867;&#30340;staticIntField&#20540;\n"</span>);
    printf(<span style="color: #8fbc8f; font-style: italic;">"         JniFuncMain.staticIntField = %d\n"</span>, staticIntField);

    // &#26597;&#25214;&#29983;&#25104;&#23545;&#35937;&#30340;&#31867;
    targetClass = new-&gt;NewObject(targetClass, mid , 100);

    // &#26597;&#25214;&#26500;&#36896;&#26041;&#27861;
    mid = env-&gt;GetMethodID(targetClass, <span style="color: #8fbc8f; font-style: italic;">"&lt;init&gt;"</span>, <span style="color: #8fbc8f; font-style: italic;">"(I)V"</span>);

    // &#29983;&#25104;JniTest&#23545;&#35937;(&#36820;&#22238;&#23545;&#35937;&#30340;&#24341;&#29992;)
    printf(<span style="color: #8fbc8f; font-style: italic;">"[CPP]JniTest&#23545;&#35937;&#29983;&#25104;\n"</span>);
    newObject = env-&gt;NewObject(targetClass, mid, 100);

    // &#35843;&#29992;&#23545;&#35937;&#30340;&#26041;&#27861;
    mid = env-&gt;GetMethodID(targetClass,<span style="color: #8fbc8f; font-style: italic;">"callByNative"</span>, <span style="color: #8fbc8f; font-style: italic;">"(I)I"</span>);
    result = env-&gt;CallIntMethod(newObject, mid , 200);

    //&#35774;&#32622;JniObject&#23545;&#35937;&#30340;intField&#20540;
    fid = env-&gt;GetFieldID(targetClass, <span style="color: #8fbc8f; font-style: italic;">"intField"</span>, <span style="color: #8fbc8f; font-style: italic;">"I"</span>);
    printf(<span style="color: #8fbc8f; font-style: italic;">"[CPP] &#35774;&#32622;JniTest&#23545;&#35937;&#30340;intField&#20540;&#20026;200\n"</span>);
    env-&gt;SetIntField(newObject, fid, result);

    //&#36820;&#22238;&#23545;&#35937;&#30340;&#24341;&#29992;
    return newObject;
}
</pre>




</div>

</div>

<div id="outline-container-2.3.3" class="outline-5">
<h5 id="sec-2.3.3">2.3.3 通过JNI,获取成员变量值 </h5>
<div id="text-2.3.3">


<p>
下面代码用于获取JniFuncMaind类的staticIntField成员变量的值
</p>



<pre class="src src-c">
<span style="color: #cccccc; font-style: italic;">// </span><span style="color: #cccccc; font-style: italic;">1. &#26597;&#25214;&#21547;&#26377;&#24453;&#25918;&#25991;&#25104;&#21592;&#21464;&#37327;&#30340;JniFuncMain&#31867;&#30340;jclass&#20540;
</span><span style="color: #cccccc; font-style: italic;">// </span><span style="color: #cccccc; font-style: italic;">2. &#33719;&#21462;staticField&#21464;&#37327;&#30340;ID&#20540;
</span>fid = env-&gt;GetStaticFieldID(clazz, <span style="color: #8fbc8f; font-style: italic;">"staticIntField"</span>, <span style="color: #8fbc8f; font-style: italic;">"I"</span>);
<span style="color: #cccccc; font-style: italic;">// </span><span style="color: #cccccc; font-style: italic;">3. &#35835;&#21462;jclass&#19982;fieldid&#25351;&#23450;&#30340;&#25104;&#21592;&#21464;&#37327;&#20540;
</span>staticIntField = env-&gt;GetStaticIntField(clazz, fid);
</pre>




<p>
程序通过JNI访问java类/对象的成员变量安如下顺序进行：
</p>
<p>
(1) 查找含待放文的成员变量的Java类的jclass值
(2) 获取此类成员变量的jfieldID值。若成员变量为静态变量，则调用名称为GetStaticFieldID()的JNI函数；若待访问的成员变量是普通对象，则调用名称为GetFieldID()的JNI函数。
(3) 使用12中获得的jclass与jfieldID值，获取或设置成员变量值。
</p>
<p>
依据以上顺序，待读取树脂的staticIntField成员变量在JniFuncMain类被声明。JniFuncMain类的jclass值被传递给JNI本地函数 <code>java_JniFuncMain_createJniObject()</code> 的第二个参数中，若想获取指定类的jclass值，调用JNI函数FindClass()即可。
</p>
<p>
若想在本地代码中访问Java的成员变量，必须获取相应成员变量的ID值。例子中成员变量的ID保存在jfieldID类型的变量中。由于待读取数值的staticIntField成员变量时JniFUncMain类的静态变量，在获取staticIntField的ID时，影调用名称为GetStaticFieldID()的JNI函数。
</p>
<p>
在例子中的GetStaticFieldID()函数，与下表中的GetStaticFieldID()函数原型有些不同，函数原型中带有四个参数，而代码中仅有三个，缺少了env参数，这不是错误，而是与所用的编程语言相关。具体请参考后面Tip中关于JNI函数编码风格的说明。
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<col align="left"></col><colgroup><col align="left"></col>
</colgroup>
<thead>
<tr><th>JNI函数 - GetStaticFieldID()</th><th></th></tr>
</thead>
<tbody>
<tr><td>形式</td><td>jfield GetStaticFieldID(JNIEnv *env, jclass clazz, const char*name, const char *signature)</td></tr>
</tbody>
<tbody>
<tr><td>说明</td><td>返回指定类的指定的静态变量的jfieldID的值</td></tr>
</tbody>
<tbody>
<tr><td>参数</td><td>env-JNI接口指针 clazz-包含成员变量的类的jclass name-成员变量名 signature-成员变量签名</td></tr>
</tbody>
</table>


<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<col align="left"></col><colgroup><col align="left"></col>
</colgroup>
<thead>
<tr><th>JNI函数 - GetFieldID()</th><th></th></tr>
</thead>
<tbody>
<tr><td>形式</td><td>jfield GetFieldID(JNIEnv *env, jclass clazz, const char *name, const char *signature)</td></tr>
</tbody>
<tbody>
<tr><td>说明</td><td>返回对象中指定的成员变量的jfieldID的值</td></tr>
</tbody>
<tbody>
<tr><td>参数</td><td>env-JNI接口指针 clazz-包含成员变量的类的jclass name-成员变量名 signatuer-成员变量签名</td></tr>
</tbody>
</table>


<p>
以上两个函数都要去提供成员变量的签名。成员变量与成员方法都拥有签名，使用 <code>&lt;JDK_HOME&gt;/bin</code> 目录下的javap命令(java反编译器)，可以获取成员变量活成员方法签名。
</p>
<p>
Tip: 在JNI中获取成员变量活成员方法签名
</p>
<p>
形式： javap <code>[选项]</code>  '类名'
</p>
<p>
选项： -s 输出java签名
-p 输出所有类及成员
</p>
<p>
在获取成员变量所在的类与ID后，根据各个成员变量的类型与存储区块(static或non-static)，调用相应的JNI函数读取成员变量值即可。在JNI中有两种函数用来获取成员便令的值，分别为Get&lt;type&gt;Field函数与GetStatic&lt;type&gt; Field函数。&lt;type&gt;指Int, Char, Double等基本数据类型，具体参考JNI文档。
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<col align="left"></col><colgroup><col align="left"></col>
</colgroup>
<thead>
<tr><th>JNI函数 GetStatic&lt;type&gt;Field</th><th></th></tr>
</thead>
<tbody>
<tr><td>形式</td><td>&lt;jnitype&gt;GetStatic&lt;type&gt;Field(JNIEnv *env, jclass clazz, jfieldID fieldID)</td></tr>
</tbody>
<tbody>
<tr><td>说明</td><td>返回clazz类中ID为fieldID的静态变量的值</td></tr>
</tbody>
<tbody>
<tr><td>参数</td><td>env-JNI接口指针 clazz-包含成员变量的类 fieldID-成员变量的ID</td></tr>
</tbody>
<tbody>
<tr><td>参考</td><td>&lt;type&gt;指Object、Boolean、Byte、Char、Short、Int、Long、Float、Double九种基本类型</td></tr>
<tr><td></td><td>返回类型&lt;jnitype&gt;指jobject、jboolean、jbyte、jchar、jshort、jint、jlong、jfloat、jdouble九种基本类型</td></tr>
</tbody>
<tbody>
<tr><td>返回值</td><td>返回静态成员变量的值</td></tr>
</tbody>
</table>


<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<col align="left"></col><colgroup><col align="left"></col>
</colgroup>
<thead>
<tr><th>JNI函数 Get&lt;type&gt;Field</th><th></th></tr>
</thead>
<tbody>
<tr><td>形式</td><td>&lt;jnitype&gt;Get&lt;type&gt;Field(JNIEnv *env, Jobject obj, jfieldID fieldID)</td></tr>
</tbody>
<tbody>
<tr><td>说明</td><td>返回obj对象中ID为fieldID的成员变量的值</td></tr>
</tbody>
<tbody>
<tr><td>参数</td><td>env-JNI接口指针</td></tr>
<tr><td></td><td>obj-包含成员变量的对象</td></tr>
<tr><td></td><td>fieldID-成员变量的ID</td></tr>
</tbody>
<tbody>
<tr><td>返回值</td><td>返回成员变量的值</td></tr>
</tbody>
</table>

由于staticIntField是Int类型的静态成员变量，所以调用GetStaticFieldID()函数即可获取StaticIntField的值.

<p>
生成对象
</p>
<p>
在JNI本地函数中如何生成Java类对象呢？

</p>
<hr/>
<p>
// 1. 查找生成对象的类
targetClass = env-&gt;FindClass("JniTest");
</p>
<p>
// 2. 查找类的构造方法
mid = env-&gt;GetMethodID(targetClass, "&lt;init&gt;", "(I)V");
</p>
<p>
// 3. 生成JniTest类对象(返回对象引用)
newObject = env-&gt;NewObject(targetClass, mid, 100);

</p>
<hr/>

<p>
通过JNI函数，生成Java对象的顺序如下：
</p><ol>
<li>
查找指定的类，并将查找到的类赋值给jclass类型的变量。

</li>
<li>
查找java类构造方法的ID值，类型为jmethodID。

</li>
<li>
生成java类对象

</li>
</ol>

<p>首先调用JNI函数FindClass()，查找生成对象的类。将类名作为FindClass()函数参数，查找并获得jclass值
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<col align="left"></col><col align="left"></col>
<thead>
<tr><th>JNI函数 FindClass</th><th></th></tr>
</thead>
<tbody>
<tr><td>形式</td><td>jclass FindClass(JNIEnv *env, const char *name)</td></tr>
</tbody>
<tbody>
<tr><td>说明</td><td>查找name指定的Java类</td></tr>
</tbody>
<tbody>
<tr><td>参数</td><td>env-JNI接口指针</td></tr>
<tr><td></td><td>name-待查找的类名</td></tr>
</tbody>
<tbody>
<tr><td>返回值</td><td>返回jclass的值</td></tr>
</tbody>
</table>


<p>
获取类的构造方法的ID并保存在jmethodID变量中。在JNI函数中有一个GetMethodID()函数用来获取指定类的指定方法ID。此函数除了可以用来获取指定类的构造方法的ID外，还可以获取类的其他的方法的ID。若指定的是静态方法，则可以调用JNI函数中的GetStaticMethodID()函数，获得指定静态方法的ID。
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<col align="left"></col><col align="left"></col>
<thead>
<tr><th>JNI函数 GetMethodID</th><th></th></tr>
</thead>
<tbody>
<tr><td>形式</td><td>jmethodID GetMethodID(JNIEnv *env, jclass clazz, const char *name, const char *signature)</td></tr>
</tbody>
<tbody>
<tr><td>说明</td><td>获取clazz类对象的指定方法ID。注意，方法名(name)与签名应当保持一致。若获取类构造方法的ID，方法名应为&lt;init&gt;</td></tr>
</tbody>
<tbody>
<tr><td>参数</td><td>env: JNI接口指针</td></tr>
<tr><td></td><td>clazz:Java类</td></tr>
<tr><td></td><td>name：方法名</td></tr>
<tr><td></td><td>signature：方法签名</td></tr>
</tbody>
<tbody>
<tr><td>返回值</td><td>若方法ID错误，则返回NULL</td></tr>
</tbody>
</table>


<p>
以类的jclass与构造方法ID为参数，调用函数NewObject()函数生成JniTest类的对象。JniTest类的构造方法JniTest(int num)带有一个int类型的参数，在调用NewObject()时，同时传入100这一int数据。在生成类对象后，将对象的引用保存在jobject变量中。
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<col align="left"></col><col align="left"></col>
<thead>
<tr><th>JNI函数 NewObject</th><th></th></tr>
</thead>
<tbody>
<tr><td>形式</td><td>jobject NewObject(JNIEnv *env, jclass clazz, jmethodID methodID, &hellip;)</td></tr>
</tbody>
<tbody>
<tr><td>说明</td><td>生成指定类的对象。methodID指类的构造方法的ID</td></tr>
</tbody>
<tbody>
<tr><td>参数</td><td>env:JNI接口指针</td></tr>
<tr><td></td><td>clazz: Java类</td></tr>
<tr><td></td><td>methodID:类的构造方法的ID</td></tr>
<tr><td></td><td>&hellip;:传递给类构造方法的参数</td></tr>
</tbody>
<tbody>
<tr><td>返回值</td><td>返回类对象的引用。若发生错误，返回NULl</td></tr>
</tbody>
</table>


<p>
Tip: 局部引用与全局引用
</p>
<p>
在实现JNI本地函数时，由GetObjectClass()、FindClass()等JNI函数返回的jclass\jobject等引用都是局部引用(Local Reference)
</p>
<p>
局部引用是JNI默认的，它仅在JNI本地函数内部有效，即当JNI本地函数返回后，其内部的引用就会失效。
</p>
<p>
在JNI编程中，实现JNI本地函数时，必须准确地理解局部引用的含义。
下面再举一个例子进一步详细的说明一下。
</p>



<pre class="src src-java">
<span style="color: #add8e6; font-weight: bold;">class</span> <span style="color: #9acd32; font-weight: bold;">RefTest</span>
{
    <span style="color: #add8e6; font-weight: bold;">public</span> <span style="color: #add8e6; font-weight: bold;">static</span> <span style="color: #9acd32; font-weight: bold;">int</span> <span style="color: #add8e6; font-weight: bold; font-style: italic;">intField</span>;

    <span style="color: #add8e6; font-weight: bold;">public</span> <span style="color: #add8e6; font-weight: bold;">static</span> <span style="color: #9acd32; font-weight: bold;">void</span> <span style="color: #ffff00; font-weight: bold; font-style: italic;">setField</span>(<span style="color: #9acd32; font-weight: bold;">int</span> <span style="color: #add8e6; font-weight: bold; font-style: italic;">num</span>) {
        <span style="color: #9acd32; font-weight: bold;">int</span> <span style="color: #add8e6; font-weight: bold; font-style: italic;">Field</span> = num;
    }
}

<span style="color: #add8e6; font-weight: bold;">public</span> <span style="color: #add8e6; font-weight: bold;">class</span> <span style="color: #9acd32; font-weight: bold;">RefTestMain</span>
{
    <span style="color: #cccccc; font-style: italic;">// </span><span style="color: #cccccc; font-style: italic;">&#21152;&#36733;&#26412;&#22320;&#24211;
</span>    <span style="color: #add8e6; font-weight: bold;">static</span> { System.loadLibrary(<span style="color: #8fbc8f; font-style: italic;">"reftest"</span>e); }

    <span style="color: #cccccc; font-style: italic;">// </span><span style="color: #cccccc; font-style: italic;">&#22768;&#26126;&#26412;&#22320;&#26041;&#27861;
</span>    <span style="color: #add8e6; font-weight: bold;">public</span> <span style="color: #add8e6; font-weight: bold;">static</span> <span style="color: #add8e6; font-weight: bold;">native</span> <span style="color: #9acd32; font-weight: bold;">int</span> <span style="color: #ffff00; font-weight: bold; font-style: italic;">getMember</span>();

    <span style="color: #add8e6; font-weight: bold;">public</span> <span style="color: #add8e6; font-weight: bold;">static</span> <span style="color: #9acd32; font-weight: bold;">void</span> <span style="color: #ffff00; font-weight: bold; font-style: italic;">main</span>(<span style="color: #9acd32; font-weight: bold;">String</span>[] <span style="color: #add8e6; font-weight: bold; font-style: italic;">args</span>) {
        RefTest.setField(100);
        System.out.println(<span style="color: #8fbc8f; font-style: italic;">"intField = "</span> + getMember());
        RefTest.setField(200);
        System.out.println(<span style="color: #8fbc8f; font-style: italic;">"intField = "</span> + getMember());
    }
}
</pre>




<p>
其中，本地方法getMember()的具体实现在reftest.cpp中。为了说明局部引用问题，声明了一个静态jclass变量targetClass，准备保存类的引用。
</p>


<pre class="src src-c">
<span style="color: #add8e6; font-weight: bold;">static</span> <span style="color: #9acd32; font-weight: bold;">jclass</span> <span style="color: #add8e6; font-weight: bold; font-style: italic;">targetClass</span> = 0;
JNIEXPORT jint <span style="color: #9acd32; font-weight: bold;">JNICALL</span> <span style="color: #ffff00; font-weight: bold; font-style: italic;">Java_RefTestMain_getMember</span>(<span style="color: #9acd32; font-weight: bold;">JNIEnv</span> *<span style="color: #add8e6; font-weight: bold; font-style: italic;">env</span>, <span style="color: #9acd32; font-weight: bold;">jclass</span> <span style="color: #add8e6; font-weight: bold; font-style: italic;">clazz</span>)
{
    <span style="color: #9acd32; font-weight: bold;">jfieldID</span> <span style="color: #add8e6; font-weight: bold; font-style: italic;">fid</span>;
    <span style="color: #9acd32; font-weight: bold;">jint</span> <span style="color: #add8e6; font-weight: bold; font-style: italic;">intField</span>;
    <span style="color: #9acd32; font-weight: bold;">jclass</span> <span style="color: #add8e6; font-weight: bold; font-style: italic;">targetClass</span>;

    <span style="color: #add8e6; font-weight: bold;">if</span>(targetClass == 0) {
        targetClass = env-&gt;FindClass(RefTest<span style="color: #ffa07a; font-weight: bold;">"</span><span style="color: #8fbc8f; font-style: italic;">);
    }
    fid = env-&gt;GetStaticFieldID(targetClass, "</span>intField<span style="color: #8fbc8f; font-style: italic;">", "</span>I<span style="color: #ffa07a; font-weight: bold;">"</span><span style="color: #8fbc8f; font-style: italic;">);
    intField = env-&gt;GetStaticIntFIeld(targetClass, fid);

    return intField;
}
</span></pre>




<p>
运行程序会报错，原因在于JNI函数中的if (targetClass == 0)的判断，在java中的两次调用，第一次调用时targetClass还为0，第二次就不为0了。第二次没有调用FindClass造成出现错误。
</p>
<p>
为了解决这一问题，JNI提供了一个名为NewGlobalRef()的JNI函数，用来为指定的类或对象生成全局引用(Global Reference)，以便在JNI本地函数中在全局范围内使用该引用。
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<col align="left"></col><col align="left"></col>
<thead>
<tr><th>JNI函数 NewGlobalRef</th><th></th></tr>
</thead>
<tbody>
<tr><td>形式</td><td>jobject NewGlobalRef(JNIEnv *env, jobject obj)</td></tr>
</tbody>
<tbody>
<tr><td>说明</td><td>为obj指定的类或对象，生成全局引用</td></tr>
</tbody>
<tbody>
<tr><td>参数</td><td>env: JNI接口指针</td></tr>
<tr><td></td><td>obj: 待生成全局引用的引用值</td></tr>
</tbody>
<tbody>
<tr><td>返回值</td><td>返回生成的全局引用，所发生错误，返回NULL</td></tr>
</tbody>
</table>


<p>
当全局引用使用完后，应当调用名称为DeleteGlobalRef()的JNI函数，显性的将全局引用销毁。
</p>



<pre class="src src-c">
<span style="color: #0000cd;">#include</span> <span style="color: #8fbc8f; font-style: italic;">"RefTestMain.h"</span>

<span style="color: #add8e6; font-weight: bold;">static</span> <span style="color: #9acd32; font-weight: bold;">jclass</span> <span style="color: #add8e6; font-weight: bold; font-style: italic;">globalTargetClass</span> = 0;

JNIEXPORT jint <span style="color: #9acd32; font-weight: bold;">JNICALL</span> <span style="color: #ffff00; font-weight: bold; font-style: italic;">Java_RefTestMain_getMember</span> (<span style="color: #9acd32; font-weight: bold;">JNIEnv</span> *<span style="color: #add8e6; font-weight: bold; font-style: italic;">env</span>, <span style="color: #9acd32; font-weight: bold;">jclass</span> <span style="color: #add8e6; font-weight: bold; font-style: italic;">jclazz</span>)
{
    <span style="color: #9acd32; font-weight: bold;">jfieldID</span> <span style="color: #add8e6; font-weight: bold; font-style: italic;">fid</span>;
    <span style="color: #9acd32; font-weight: bold;">jint</span> <span style="color: #add8e6; font-weight: bold; font-style: italic;">intField</span>;
    <span style="color: #9acd32; font-weight: bold;">jclass</span> <span style="color: #add8e6; font-weight: bold; font-style: italic;">targetClass</span>;
    
    <span style="color: #add8e6; font-weight: bold;">if</span>(globalTargetClass == 0) {
        targetClass = env-&gt;FindClass(<span style="color: #8fbc8f; font-style: italic;">"RefTest"</span>);
        globalTargetClass = (<span style="color: #9acd32; font-weight: bold;">jclass</span>)env-&gt;NewGlobalRef(targetClass);
    }

    fid = env-&gt;GetStaticFieldID(globalTargetClass, <span style="color: #8fbc8f; font-style: italic;">"initField"</span>, <span style="color: #8fbc8f; font-style: italic;">"I"</span>);
    intField = env-&gt;GetStaticIntField(globalTargetClass, fid);

    <span style="color: #add8e6; font-weight: bold;">return</span> intField;
}
</pre>




<p>
上面代码调用了NewGlobalRef()函数，将targetClass中保存的RefTest类的局部引用(由FindClass()函数返回)转换成全局引用。并且将生成的全局引用保存在globalTargetClass静态变量中。
</p>
<p>
局部引用在函数执行完程后即无效。而全局引用除非调用DeleteGlobalRef()明确将其销毁，不然这个全局引用总是有效的，可以在运行库的其他函数中使用该引用。
</p>
</div>

</div>

<div id="outline-container-2.3.4" class="outline-5">
<h5 id="sec-2.3.4">2.3.4 调用Java方法 </h5>
<div id="text-2.3.4">


<p>
下面描述了如何使用JNI函数调用Java方法，并将返回值保存至JNI本地函数的变量中的过程

</p>
<hr/>
<p>
// 1. 获取含待调用方法的Java类的jclass
targetClass = env-&gt;GetObjectClass(newObject);
</p>
<p>
// 2. 获取待调用方法的ID
mid = env-&gt;GetMethodID(targetClass, "callByNative", "(I)I");
</p>
<p>
// 3. 调用Java方法 保存返回值
result = env-&gt;CallIntMethod(newObject, mid, 200);

</p>
<hr/>

<p>
通过JNI调用Java方法的顺序如下
</p><ol>
<li>
获取含待调用方法的Java类的jclass。若待调用方法属于某个Java类对象，则该方法用来获取Java类对象的jobject。

</li>
<li>
调用GetMethodID()函数，获取待调用方法的ID(jMethodID)。使用jclass与GetMethodID()函数

</li>
<li>
根据返回值类型，调用相应的JNI函数，实现对Java方法的调用。若待调用的Java方法是静态方法，则调用函数的形式应为CallStatic&lt;type&gt;Method();若待调用的方法属于某个类对象，则调用函数的形式应为Call&lt;type&gt;Method()。

</li>
</ol>

<p>程序首先获取含callByNative()方法的JniTest类的jclass。在获取JniTest类的jclass时，可以直接调用FindClass()函数，将类引用保存在targetClass中。但是为了向各位介绍GetObjectClass()这个JNI函数，因而在此调用了GetObjectClass()函数。
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<col align="left"></col><col align="left"></col>
<thead>
<tr><th>JNI函数 CallStatic&lt;type&gt;Method()</th><th></th></tr>
</thead>
<tbody>
<tr><td>形式</td><td>&lt;jnitype&gt;CallStatic&lt;type&gt;Method(JNIEnv *env, jcalss clazz,jmethodID methodID, &hellip;)</td></tr>
</tbody>
<tbody>
<tr><td>说明</td><td>调用methodID指定的类的静态方法</td></tr>
</tbody>
<tbody>
<tr><td>参数</td><td>env: JNI接口指针</td></tr>
<tr><td></td><td>clazz: 含待调方法的类</td></tr>
<tr><td></td><td>methodID：待调方法的ID 由GetStaticMethodID()函数获取</td></tr>
<tr><td></td><td>&hellip;：传递给待调方法的参数</td></tr>
</tbody>
<tbody>
<tr><td>返回值</td><td>被调方法的返回值</td></tr>
</tbody>
<tbody>
<tr><td>参考</td><td>&lt;type&gt;除了前面说&lt;Get&lt;type&gt;FieldID()时列出的九种外又添加了void类型，返回值&lt;jnitype&gt;也增加了void类型。 待调方法的返回值不同，&lt;type&gt;也不同。若待调方法的返回值类型为int, 则调用函数为CallStaticIntMethod()</td></tr>
</tbody>
</table>


<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<col align="left"></col><col align="left"></col>
<thead>
<tr><th>JNI函数 Call&lt;type&gt;Method()</th><th></th></tr>
</thead>
<tbody>
<tr><td>形式</td><td>&lt;jnitype&gt;Call&lt;type&gt;Method(JNIEnv　*env, jobject obj, jmethodID methodID, &hellip;)</td></tr>
</tbody>
<tbody>
<tr><td>说明</td><td>调用methodID指定的java对象的方法</td></tr>
</tbody>
<tbody>
<tr><td>参数</td><td>env: JNI接口指针</td></tr>
<tr><td></td><td>obj: 含待调方法的Java对象的引用</td></tr>
<tr><td></td><td>methodID: 待调用方法的ID，由GetMethodID()函数来获取</td></tr>
<tr><td></td><td>&hellip;: 传递给待调用方法的参数</td></tr>
</tbody>
<tbody>
<tr><td>返回值</td><td>被调用方法的返回值</td></tr>
</tbody>
</table>


</div>

</div>

<div id="outline-container-2.3.5" class="outline-5">
<h5 id="sec-2.3.5">2.3.5 通过JNI设置成员变量的值 </h5>
<div id="text-2.3.5">



<hr/>
<p>
// 1. 获取含IntField成员变量的JniTest类的jclass值
// 类引用已经被保存到targetClass中
</p>
<p>
// 2. 获取JniTest对象的IntField变量值
fid = env-&gt;GetFieldID(targetClass, "intField", "I");
</p>
<p>
// 3. 将result值设置为IntField值
env-&gt;SetIntField(newObject, fid, resutl);

</p>
<hr/>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<col align="left"></col><col align="left"></col>
<thead>
<tr><th>JNI函数 SetStatic&lt;type&gt;Field</th><th></th></tr>
</thead>
<tbody>
<tr><td>形式</td><td>void SetStatic&lt;type&gt;Field(JNIEnv *env, jclass clazz, jfieldID fieldID, &lt;type&gt;value)</td></tr>
</tbody>
<tbody>
<tr><td>说明</td><td>设置fieldID指定的Java类静态成员变量的值</td></tr>
</tbody>
<tbody>
<tr><td>参数</td><td>env: JNI接口指针</td></tr>
<tr><td></td><td>clazz: 含待设置成员变量的类的引用</td></tr>
<tr><td></td><td>fieldID: 待设成员变量的ID，由GetStaticFieldID()函数获取</td></tr>
<tr><td></td><td>value: 指定设置值</td></tr>
</tbody>
</table>


<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<col align="left"></col><col align="left"></col>
<thead>
<tr><th>JNI函数 Set&lt;type&gt;Field</th><th></th></tr>
</thead>
<tbody>
<tr><td>形式</td><td>void Set&lt;type&gt;Field (JNIEnv *env, jobject obj, jfieldID fieldID, &lt;type&gt; value)</td></tr>
</tbody>
<tbody>
<tr><td>说明</td><td>设置fieldID指定的Java对象的成员变量</td></tr>
</tbody>
<tbody>
<tr><td>参数</td><td>env: JNI接口指针</td></tr>
<tr><td></td><td>obj: 包含待设成员变量的Java对象的引用</td></tr>
<tr><td></td><td>fieldID: 待设成员变量的ID，由GetFieldID()函数获取</td></tr>
<tr><td></td><td>value:指定设置值</td></tr>
</tbody>
</table>


</div>
</div>
</div>

</div>

<div id="outline-container-3" class="outline-2">
<h2 id="sec-3">3 在C程序中运行Java类 </h2>
<div id="text-3">


<p>
本节中学习在由C/C++编写的主程序中如何运行Java类，这也是使用JNI的重要方式。
</p>
<p>
在C/C++程序中运行Java类也必须使用Java虚拟机。为此JNI提供了一套Invocation API，它允许本地代码在自身内存区域内加载Java虚拟机。
</p>
<p>
下面列出的可能使你决定使用Invocation API在C/C++代码中调用Java代码的集中典型情况：
</p>
<ul>
<li>
需要在C/C++编写的本地应用程序中访问用Java语言编写的代码或代码库

</li>
<li>
希望在C/C++编写的本地应用程序中使用标准的Java库

</li>
<li>
当需要把自己已有的C/C++程序与Java程序组织链接在一起时，使用Invocation API可以将它们组织成一个完整的程序

</li>
</ul>

</div>

<div id="outline-container-3.1" class="outline-3">
<h3 id="sec-3.1">3.1 Invocaton API 应用示例 </h3>
<div id="text-3.1">

<p>实例程序由InvokeJava.cpp与InvocationTest.java两个文件构成
</p>
<p>
示例程序将按如下顺序执行:
</p>
<p>
(1) 主程序InvokeJava.cpp使用Invocation API加载Java虚拟机。
</p>
<p>
(2) 通过JNI函数加载InvocationTest类至内存中
</p>
<p>
(3) 执行被加载的InvocatonTest类main()方法
</p>

</div>

<div id="outline-container-3.1.1" class="outline-4">
<h4 id="sec-3.1.1">3.1.1 分析Java代码 InvocationApiTest.java </h4>
<div id="text-3.1.1">





<pre class="src src-java">
<span style="color: #add8e6; font-weight: bold;">public</span> <span style="color: #add8e6; font-weight: bold;">class</span> <span style="color: #9acd32; font-weight: bold;">InvocationAPiTest</span> 
{
    <span style="color: #add8e6; font-weight: bold;">public</span> <span style="color: #add8e6; font-weight: bold;">static</span> <span style="color: #9acd32; font-weight: bold;">void</span> <span style="color: #ffff00; font-weight: bold; font-style: italic;">main</span>(<span style="color: #9acd32; font-weight: bold;">String</span>[] <span style="color: #add8e6; font-weight: bold; font-style: italic;">args</span>)
    {
        System.out.println(args[0]);
    }
}
</pre>



<p>
<code>仅含有一个main()方法，该main()方法是一个静态方法，带有一个字符串对象数组，在方法体中仅有一条输出语句，用来降低一个数组元素args[1]中的字符串输出到控制台上。</code>
</p>
</div>

</div>

<div id="outline-container-3.1.2" class="outline-4">
<h4 id="sec-3.1.2">3.1.2 分析C代码 invocationApi.c </h4>
<div id="text-3.1.2">




<pre class="src src-c">
<span style="color: #0000cd;">#include</span> <span style="color: #8fbc8f; font-style: italic;">&lt;jni.h&gt;</span>

<span style="color: #9acd32; font-weight: bold;">int</span> <span style="color: #ffff00; font-weight: bold; font-style: italic;">main</span>() 
{
    <span style="color: #9acd32; font-weight: bold;">JNIEnv</span> *<span style="color: #add8e6; font-weight: bold; font-style: italic;">env</span>;
    <span style="color: #9acd32; font-weight: bold;">JavaVM</span> *<span style="color: #add8e6; font-weight: bold; font-style: italic;">vm</span>;
    <span style="color: #9acd32; font-weight: bold;">JavaVMInitArgs</span> <span style="color: #add8e6; font-weight: bold; font-style: italic;">vm_args</span>;
    <span style="color: #9acd32; font-weight: bold;">JavaVMOptions</span> <span style="color: #add8e6; font-weight: bold; font-style: italic;">options</span>[1];
    <span style="color: #9acd32; font-weight: bold;">jint</span> <span style="color: #add8e6; font-weight: bold; font-style: italic;">res</span>;
    <span style="color: #9acd32; font-weight: bold;">jclass</span> <span style="color: #add8e6; font-weight: bold; font-style: italic;">cls</span>;
    <span style="color: #9acd32; font-weight: bold;">jmethodID</span> <span style="color: #add8e6; font-weight: bold; font-style: italic;">mid</span>;
    <span style="color: #9acd32; font-weight: bold;">jstring</span> <span style="color: #add8e6; font-weight: bold; font-style: italic;">jstr</span>;
    <span style="color: #9acd32; font-weight: bold;">jclass</span> <span style="color: #add8e6; font-weight: bold; font-style: italic;">stringClass</span>;
    <span style="color: #9acd32; font-weight: bold;">jobjectArray</span> <span style="color: #add8e6; font-weight: bold; font-style: italic;">args</span>;

    <span style="color: #cccccc; font-style: italic;">// </span><span style="color: #cccccc; font-style: italic;">1. &#29983;&#25104;Java&#34394;&#25311;&#26426;&#36873;&#39033;
</span>    options[0].optionString = <span style="color: #8fbc8f; font-style: italic;">"-Djava.class.path=."</span>
    vm_args.version = 0x00010002;
    vm_args.options = options;
    vm_args.nOptions = 1;
    vm_args.ignoreUnrecognized = JNI_TRUE;

    <span style="color: #cccccc; font-style: italic;">// </span><span style="color: #cccccc; font-style: italic;">2. &#29983;&#25104;Java&#34394;&#25311;&#26426;
</span>    res = JNI_CreateJavaVM(&amp;vm, (<span style="color: #9acd32; font-weight: bold;">void</span>**)&amp;env, &amp;vm_args);

    <span style="color: #cccccc; font-style: italic;">// </span><span style="color: #cccccc; font-style: italic;">3. &#26597;&#25214;&#24182;&#21152;&#36733;&#31867;
</span>    cls = (*env)-&gt;FindClass(env, <span style="color: #8fbc8f; font-style: italic;">"InvocationApiTest"</span>);

    <span style="color: #cccccc; font-style: italic;">// </span><span style="color: #cccccc; font-style: italic;">4. &#33719;&#21462;main()&#26041;&#27861;&#30340;ID
</span>    mid = (*env)-&gt;GetStaticMethodID(env, cls, <span style="color: #8fbc8f; font-style: italic;">"main"</span>, ([Ljava/lang/String;)V);

    <span style="color: #cccccc; font-style: italic;">// </span><span style="color: #cccccc; font-style: italic;">5. &#29983;&#25104;&#23383;&#31526;&#20018;&#23545;&#35937;&#65292;&#29992;&#20316;main()&#26041;&#27861;&#30340;&#21442;&#25968;
</span>    jstr = (*env)-&gt;NewStringUTF(env, <span style="color: #8fbc8f; font-style: italic;">"Hello Invacation API!!"</span>);    
    stringClass = (*env)-&gt;NewObjectArray(env, 1, stringClass, jstr);
    args = (*env)-&gt;NewObjectArray(env, 1, stringClass, jstr);

    <span style="color: #cccccc; font-style: italic;">// </span><span style="color: #cccccc; font-style: italic;">6. &#35843;&#29992;main()&#26041;&#27861;
</span>    &#65288;*env)-&gt;CallStaticVoidMethod(env, cls, mid, args);
    
    <span style="color: #cccccc; font-style: italic;">// </span><span style="color: #cccccc; font-style: italic;">7. &#38144;&#27585;Java&#34394;&#25311;&#26426;
</span>    (*vm)-&gt;DestroyJavaVM(vm);
}
</pre>




<p>
下面开始分析代码的主要部分
</p>




<pre class="src src-java">
    <span style="color: #cccccc; font-style: italic;">// </span><span style="color: #cccccc; font-style: italic;">1. &#29983;&#25104;Java&#34394;&#25311;&#26426;&#36873;&#39033;
</span>    options[0].optionString = <span style="color: #8fbc8f; font-style: italic;">"-Djava.class.path=."</span>
    vm_args.version = 0x00010002;
    vm_args.options = options;
    vm_args.nOptions = 1;
    vm_args.ignoreUnrecognized = JNI_TRUE;
</pre>



<p>
生成一些参数或选项值，这些值在加载Java虚拟机时被引用，用来设置Java虚拟机的运行环境或控制Java虚拟机的运行，如设置CLASSPATH或输出调试信息等。
</p>
<p>
在生成Java虚拟机选项时，使用JavaVMInitArgs与JavaVMOption结构体，它们定义在jni.h头文件中
</p>


<pre class="src src-c">
<span style="color: #add8e6; font-weight: bold;">typedef</span> <span style="color: #add8e6; font-weight: bold;">struct</span> <span style="color: #9acd32; font-weight: bold;">JavaVMInitArgs</span> {
    <span style="color: #9acd32; font-weight: bold;">jint</span> <span style="color: #add8e6; font-weight: bold; font-style: italic;">version</span>;
    <span style="color: #9acd32; font-weight: bold;">jint</span> <span style="color: #add8e6; font-weight: bold; font-style: italic;">nOptions</span>;
    <span style="color: #9acd32; font-weight: bold;">JavaVMOption</span> *<span style="color: #add8e6; font-weight: bold; font-style: italic;">options</span>;
    <span style="color: #9acd32; font-weight: bold;">jboolean</span> <span style="color: #add8e6; font-weight: bold; font-style: italic;">ignoreUnrecognized</span>;
} <span style="color: #add8e6; font-weight: bold; font-style: italic;">JavaVMInitArgs</span>;

<span style="color: #add8e6; font-weight: bold;">typedef</span> <span style="color: #add8e6; font-weight: bold;">struct</span> <span style="color: #9acd32; font-weight: bold;">JavaVMOption</span> {
    <span style="color: #9acd32; font-weight: bold;">char</span> *<span style="color: #add8e6; font-weight: bold; font-style: italic;">optionString</span>;
    <span style="color: #9acd32; font-weight: bold;">void</span> *<span style="color: #add8e6; font-weight: bold; font-style: italic;">extraInfo</span>;
} <span style="color: #add8e6; font-weight: bold; font-style: italic;">JavaVMOption</span>;
</pre>



<p>
观察JavaVMInitArgs结构体定义代码，可以发现JavaVMInitArgs结构体内包含JavaVMOption结构体的指针。JavaVMOption结构体包含Java虚拟机的各个参数，JavaVMInitArgs结构体用来将这些参数选项传递给Java虚拟机。
</p>
<p>
接下来，看一下结构体中各个成员的含义。
</p>
<p>
JavaVMInitArgs结构体的versino成员用来指定传递诶虚拟机的选项的变量的形式，设定在jni.h头文件中定义的 <code>JNI_Version_1_2</code> 的值。nOptions与options用来指定JavaVMInitArgs所指的JavaVMOption结构体数组值。nOptions指定JavaVMOption结构体数组元素的个数，options用来指向JavaVMOption结构体的地址。示例中只设置了一个Java虚拟机选项，即JavaVMOption结构体数组仅有一个元素，声明如下
</p>


<pre class="src src-c">
<span style="color: #9acd32; font-weight: bold;">JavaVMOption</span> <span style="color: #add8e6; font-weight: bold; font-style: italic;">options</span>[1];
</pre>



<p>
为了指定以上JavaVMOption结构体数组，需要指定JavaVMInitArgs的options与nOptions
</p>


<pre class="src src-c">
vm_args.options = options; <span style="color: #cccccc; font-style: italic;">// </span><span style="color: #cccccc; font-style: italic;">JavaVMOption &#32467;&#26500;&#20307;&#30340;&#22320;&#22336;
</span>vm_args.nOptions = 1; <span style="color: #cccccc; font-style: italic;">// </span><span style="color: #cccccc; font-style: italic;">JavaVMOption &#32467;&#26500;&#20307;&#25968;&#32452;&#20803;&#32032;&#20010;&#25968;
</span></pre>




<p>
ignoreUnrecognized是JavaVMInitArgs结构体jboolean类型的成员，当Java虚拟机独到设置错误的选项值时，该成员用来决定Java虚拟机是忽略错误后继续执行，还是返回错误后终止执行。若ignoreUnrecognized被设置为 <code>JNI_TRUE</code> ，Java虚拟机遇到错误选项时，忽略错误后继续执行；若被设置为 <code>JNI_FALSE</code> ，当遇到错误选项，Java虚拟机将错误返回后终止执行。
</p>
<p>
接下来分析JavaVMOption结构体，它用来指定Java虚拟机的选项值。若想创建选项值，只要向结构体的optionString成员指定一个字符串，用作Java虚拟机选项的形式。比如示例中的"-Djava.class.path=."，用来设置标准选项，即将Java虚拟机要加载的类的默认目录设置为当前目录(.)，其形式为-Dproperty=value。
</p>



<pre class="src src-c">
res = JNI_CreateJavaVM(&amp;vm, (<span style="color: #9acd32; font-weight: bold;">void</span>**)&amp;env, &amp;vm_args);
</pre>



<p>
本行代码是整个程序的核心部分，即C应用程序调用 <code>JNI_CreateJavaVM()</code> 函数，生成并装载Java虚拟机。 <code>JNI_CreateJavaVM()</code> 函数的第一个参数类型为JavaVM,它表示Java虚拟机接口，用来生成或销毁Java虚拟机。DestroyJavaVM()是接口函数之一，该函数用来销毁Java虚拟机。
</p>
<p>
在 <code>JNI_CreateJavaVM()</code> 函数的第二个参数env中，保存着JNI接口的指针的地址。通过env所指的JNI接口指针，可以使用各种JNI函数，即在C/C++中，通过env，可以生成Java对象，调用相应方法等。
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<col align="left"></col><col align="left"></col>
<thead>
<tr><th>JNI Invocation API- <code>JNI_CreateJavaVM</code></th><th></th></tr>
</thead>
<tbody>
<tr><td>形式</td><td>jint <code>JNI_CreateJavaVM</code> (javaVM **vm, JNIEnv **env, void *vm<sub>args</sub>)</td></tr>
</tbody>
<tbody>
<tr><td>说明</td><td>装载并初始化Java虚拟机</td></tr>
</tbody>
<tbody>
<tr><td>参数</td><td>vm: JavaVM指针的地址</td></tr>
<tr><td></td><td>env: JNI接口指针的地址</td></tr>
<tr><td></td><td><code>vm_args:</code> 传递给Java虚拟机的参数</td></tr>
</tbody>
<tbody>
<tr><td>返回值</td><td>成功，返回0；失败，返回负值</td></tr>
</tbody>
</table>


<p>
为了加载InvocationTest类和执行方法(向main方法传递字符串参数"Hello")，首先调用FindClass()函数，装载InvocationApiTest类。而后调用GetStaticMethodID()函数，获取main()方法的ID，准备调用main()方法。  
</p>
<p>
在使用CallStaticVoidMethod()函数调用main()方法之前，首先构造出传递给main()方法的参数。Java的main()方法的参数是String[]数组
</p>


<pre class="src src-java">
<span style="color: #add8e6; font-weight: bold;">public</span> <span style="color: #add8e6; font-weight: bold;">static</span> <span style="color: #9acd32; font-weight: bold;">void</span> <span style="color: #ffff00; font-weight: bold; font-style: italic;">main</span>(<span style="color: #9acd32; font-weight: bold;">String</span>[] <span style="color: #add8e6; font-weight: bold; font-style: italic;">args</span>)
</pre>




<p>
示例中将"Hello Invocation API!!"字符串传递给main()方法。首先调用NewStringUTF()函数，将UTF-8形式的字符串，转换成Java字符串对象String。然后调用NewObjectArray()函数，创建String对象数组，使用创建的String对象将其初始化。先创建一个含有一个元素的String[]数组，而后将"Hello Invocation API!!"字符串赋值给数组的第一个元素。
</p>



<pre class="src src-c">
    jstr = (*env)-&gt;NewStringUTF(env, <span style="color: #8fbc8f; font-style: italic;">"Hello Invacation API!!"</span>);    
    stringClass = (*env)-&gt;NewObjectArray(env, 1, stringClass, jstr);
    args = (*env)-&gt;NewObjectArray(env, 1, stringClass, jstr);
</pre>



<p>
调用JNI本地函数处理String对象的方法有些复杂。如果你对此仍迷惑不解，我们不妨将这部分代码转换成与其等价的Java代码。
</p>
<p>
如下所示，首先创建包含一个元素的字符串数组，而后将"Hello Invocation API!!"字符串赋值给数组的首个元素
</p>


<pre class="src src-java">
<span style="color: #9acd32; font-weight: bold;">String</span>[] <span style="color: #add8e6; font-weight: bold; font-style: italic;">args</span> = <span style="color: #add8e6; font-weight: bold;">new</span> <span style="color: #9acd32; font-weight: bold;">String</span>[1];
args[0] = <span style="color: #8fbc8f; font-style: italic;">"Hello Invocation API!"</span>
</pre>




<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<col align="left"></col><col align="left"></col>
<thead>
<tr><th>JNI函数 NeStringUTF</th><th></th></tr>
</thead>
<tbody>
<tr><td>形式</td><td>jstring NewStringUTF(JNIEnv *env, const char *bytes)</td></tr>
</tbody>
<tbody>
<tr><td>说明</td><td>将UTF-8形式的C字符串转换成java.lang.String对象</td></tr>
</tbody>
<tbody>
<tr><td>参数</td><td>env: JNI接口指针</td></tr>
<tr><td></td><td>bytes: 待生成String对象的C字符串的地址</td></tr>
</tbody>
<tbody>
<tr><td>返回值</td><td>成功，返回String对象的jstring类型的引用；失败，返回NULL</td></tr>
</tbody>
</table>


<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<col align="left"></col><col align="left"></col>
<thead>
<tr><th>JNI函数 NewObjectArray</th><th></th></tr>
</thead>
<tbody>
<tr><td>形式</td><td>jarray NewObjectArray(JNIEnv *env, jsize length, jclass elementClass, jobject initalElement)</td></tr>
</tbody>
<tbody>
<tr><td>说明</td><td>生成由elementClass对象组成的数组。数组元素个数由length指定，initalElement参数用来初始化对象数组</td></tr>
</tbody>
<tbody>
<tr><td>参数</td><td>env: JNI接口指针</td></tr>
<tr><td></td><td>length: 数组元素个数</td></tr>
<tr><td></td><td>elementClass:数组元素对象的类型</td></tr>
<tr><td></td><td>initialElement: 数组初始化值</td></tr>
</tbody>
<tbody>
<tr><td>返回值</td><td>若成功，则返回数组引用；失败，则返回NULL</td></tr>
</tbody>
</table>





<pre class="src src-c">
(*env)-&gt;CallStaticVoidMethod(env, cls, mid, args);
</pre>



<p>
<code>本行代码通过CallStaticVoidMethod()函数调用InvocationApiTest类的main()方法。在上面创建的Stringp[]数组是CallStaticVoidMethod()函数的第四个参数，该参数会被传递给InvocationApiTest类的main()方法。当InvocationApiTest类的main()方法被调用执行时，它会向控制台输出args字符串数组的 args[1]元素中的字符串。</code>
</p>
</div>
</div>
</div>

</div>

<div id="outline-container-4" class="outline-2">
<h2 id="sec-4">4 直接注册JNI本地函数 </h2>
<div id="text-4">


<p>
Java虚拟机在运行包含本地方法的Java应用程序时，要经过以下两个步骤。
</p>
<ol>
<li>
调用System.loadLibrary()方法，将包含本地方法具体实现的C/C++运行库加载到内存中。

</li>
<li>
Java虚拟机检索加载进来的库函数符号，在其中查找与Java本地方法拥有相同签名的JNI本地函数符号。若找到一致的，则将本地方法映射到具体的JNI本地函数。

</li>
</ol>

<p>在Android Framework这类复杂的系统下，拥有大量的包含本地方法的java类，Java虚拟机加载相应的运行库，再逐一检索，将各个本地方法与相应的函数映射起来，这显然会增加运行时间，降低运行的效率。
</p>
<p>
为此，JNI机制提供了名称为RegisterNatives()的JNI函数，该函数允许C/C++开发者将JNI本地函数与Java类的本地方法直接映射在一起。当不调用RegisterNative()函数时，Java虚拟机会自动检索并将JNI本地函数与相应的Java本地方法链接在一起。但当开发者直接调用RegisterNatives()函数进行映射时，Java虚拟机就不必进行映射处理，这会极大提高运行速度，提升运行效率。
</p>
<p>
由于程序员直接将JNI本地函数与Java本地方法链接在一起，在加载运行库时，Java虚拟机不必为了识别JNI本地函数而将JNI本地函数的名称与JNI支持的命名规则进行对比，即任何名称的函数都能直接链接到Java本地方法上。
</p>

</div>

<div id="outline-container-4.1" class="outline-3">
<h3 id="sec-4.1">4.1 加载本地库时，注册JNI本地函数 </h3>
<div id="text-4.1">





<pre class="src src-java">
#include <span style="color: #8fbc8f; font-style: italic;">"jni.h"</span>
#include &lt;stdio.h&gt;

<span style="color: #cccccc; font-style: italic;">// </span><span style="color: #cccccc; font-style: italic;">JNI&#26412;&#22320;&#20989;&#25968;&#21407;&#22411;
</span><span style="color: #9acd32; font-weight: bold;">void</span> printHelloNative(JNIEnv *env, <span style="color: #9acd32; font-weight: bold;">jobject</span> <span style="color: #add8e6; font-weight: bold; font-style: italic;">obj</span>);
<span style="color: #9acd32; font-weight: bold;">void</span> <span style="color: #ffff00; font-weight: bold; font-style: italic;">printStringNative</span>(JNIEnv *env, <span style="color: #9acd32; font-weight: bold;">jobject</span> <span style="color: #add8e6; font-weight: bold; font-style: italic;">obj</span>, <span style="color: #9acd32; font-weight: bold;">jstring</span> <span style="color: #add8e6; font-weight: bold; font-style: italic;">string</span>);

JNIEXPORT jint <span style="color: #9acd32; font-weight: bold;">JNICALL</span> <span style="color: #ffff00; font-weight: bold; font-style: italic;">JNI_Onoad</span>(JavaVM *vm, <span style="color: #9acd32; font-weight: bold;">void</span> *reserved)
{
    JNIEnv *env = NULL;
    <span style="color: #9acd32; font-weight: bold;">JNINativeMethod</span> <span style="color: #add8e6; font-weight: bold; font-style: italic;">nm</span>[2];
    <span style="color: #9acd32; font-weight: bold;">jclass</span> <span style="color: #add8e6; font-weight: bold; font-style: italic;">cls</span>;
    <span style="color: #9acd32; font-weight: bold;">jint</span> <span style="color: #add8e6; font-weight: bold; font-style: italic;">result</span> = -1;

    <span style="color: #add8e6; font-weight: bold;">if</span>(vm-&gt;GetEnv((<span style="color: #9acd32; font-weight: bold;">void</span>**)&amp;env, JNI_VERSION_1_4) != JNI_OK) {
        printf(<span style="color: #8fbc8f; font-style: italic;">"Error"</span>);
        <span style="color: #add8e6; font-weight: bold;">return</span> JNI_ERR;
    }
    
    cls = env-&gt;FindClass(<span style="color: #8fbc8f; font-style: italic;">"HelloJNI"</span>);

    nm[0].name = <span style="color: #8fbc8f; font-style: italic;">"printHello"</span>;
    nm[0].signature = <span style="color: #8fbc8f; font-style: italic;">"()V"</span>;
    nm[0].fnPtr = (<span style="color: #9acd32; font-weight: bold;">void</span>*)printHelloNative;

    nm[1].name = <span style="color: #8fbc8f; font-style: italic;">"printString"</span>;
    nm[1].signature = <span style="color: #8fbc8f; font-style: italic;">"(Ljava/lang/String;)V"</span>;
    nm[1].fnPtr = (<span style="color: #9acd32; font-weight: bold;">void</span>*)printStringNative;

    env-&gt;RegisterNatives(cls, nm, 2);

    <span style="color: #add8e6; font-weight: bold;">return</span> JNI_VERSION_1_4;
}

<span style="color: #cccccc; font-style: italic;">// </span><span style="color: #cccccc; font-style: italic;">&#23454;&#29616;JNI&#26412;&#22320;&#20989;&#25968;
</span><span style="color: #9acd32; font-weight: bold;">void</span> <span style="color: #ffff00; font-weight: bold; font-style: italic;">printHelloNative</span>(JNIEnv *env, <span style="color: #9acd32; font-weight: bold;">jobject</span> <span style="color: #add8e6; font-weight: bold; font-style: italic;">obj</span>)
{
    printf(<span style="color: #8fbc8f; font-style: italic;">"Hello World!\n"</span>);
    <span style="color: #add8e6; font-weight: bold;">return</span>;
}

<span style="color: #9acd32; font-weight: bold;">void</span> <span style="color: #ffff00; font-weight: bold; font-style: italic;">printStringNative</span>(JNIEnv *env, <span style="color: #9acd32; font-weight: bold;">jobject</span> <span style="color: #add8e6; font-weight: bold; font-style: italic;">obj</span>, <span style="color: #9acd32; font-weight: bold;">jstring</span> <span style="color: #add8e6; font-weight: bold; font-style: italic;">string</span>)
{
    <span style="color: #add8e6; font-weight: bold;">const</span> <span style="color: #9acd32; font-weight: bold;">char</span> *str = env-&gt;GetStringUTFChars(string, 0);
    printf(<span style="color: #ffa07a; font-weight: bold;">"</span><span style="color: #8fbc8f; font-style: italic;">%s!\n, str);

    return;
}
</span></pre>





<pre class="src src-java">
<span style="color: #9acd32; font-weight: bold;">void</span> <span style="color: #ffff00; font-weight: bold; font-style: italic;">printHelloNative</span>(JNIEnv *env, <span style="color: #9acd32; font-weight: bold;">jobject</span> <span style="color: #add8e6; font-weight: bold; font-style: italic;">obj</span>);
<span style="color: #9acd32; font-weight: bold;">void</span> <span style="color: #ffff00; font-weight: bold; font-style: italic;">printStringNative</span>(JNIEnv *env, <span style="color: #9acd32; font-weight: bold;">jobject</span> <span style="color: #add8e6; font-weight: bold; font-style: italic;">obj</span>, <span style="color: #9acd32; font-weight: bold;">jstring</span> <span style="color: #add8e6; font-weight: bold; font-style: italic;">string</span>);
</pre>



<p>
此两行代码用来声明JNI本地函数原型。如前所述，在使用RegisterNatives()函数机型映射时，不需要将JNI本地函数原型与JNI命名规则进行比对，所以使用的函数名比较简单。但函数中的两个公共参数必须指定为"JNIEnv *env, jobject obj"。
</p>



<pre class="src src-java">
    <span style="color: #add8e6; font-weight: bold;">if</span>(vm-&gt;GetEnv((<span style="color: #9acd32; font-weight: bold;">void</span>**)&amp;env, JNI_VERSION_1_4) != JNI_OK) {
        printf(<span style="color: #8fbc8f; font-style: italic;">"Error"</span>);
        <span style="color: #add8e6; font-weight: bold;">return</span> JNI_ERR;
</pre>



<p>
在 <code>JNI_OnLoad()</code> 函数中首先判断JNI的版本，即调用GetEnv()函数，判断Java虚拟机是否支持JNI1.4。若java虚拟机支持JNI1.4， <code>JNI_OnLoad()</code> 函数就会返回 <code>JNI_VERSION_1_4</code> ；若不支持， <code>JNI_OnLoad()</code> 函数就会返回 <code>JNI_ERR</code> ，并终止装载库的行为。
</p>
<p>
当GetEnv()函数调用完毕后，JNI接口指针被保存到env变量中，在调用FindClass()、RegisterNatives()等JNI函数时，可以使用该变量。
</p><table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<col align="left"></col><col align="left"></col>
<thead>
<tr><th>JNI Invocation API - GetEnv</th><th></th></tr>
</thead>
<tbody>
<tr><td>形式</td><td>jint GetEnv(JavaVM *vm, void **env, jint version)</td></tr>
</tbody>
<tbody>
<tr><td>说明</td><td>判断Java虚拟机是否支持version指定的JNI版本，而后将JNI接口指针设置到*env中</td></tr>
</tbody>
<tbody>
<tr><td>参数</td><td>vm: JavaVM接口指针的地址</td></tr>
<tr><td></td><td>env: JNI接口指针地址</td></tr>
<tr><td></td><td>version: JNI版本</td></tr>
</tbody>
<tbody>
<tr><td>返回值</td><td>若执行成功，返回0；失败，返回负值</td></tr>
</tbody>
</table>





<pre class="src src-java">
    cls = env-&gt;FindClass(<span style="color: #8fbc8f; font-style: italic;">"HelloJNI"</span>);
</pre>



<p>
为了把声明的JNI本地函数与JNI本地函数映射在一起，本行先调用FindClass()函数加载HelloJNI类，并将类引用保存到jclass变量cls中。
</p>



<pre class="src src-java">
    nm[0].name = <span style="color: #8fbc8f; font-style: italic;">"printHello"</span>;
    nm[0].signature = <span style="color: #8fbc8f; font-style: italic;">"()V"</span>;
    nm[0].fnPtr = (<span style="color: #9acd32; font-weight: bold;">void</span>*)printHelloNative;

    nm[1].name = <span style="color: #8fbc8f; font-style: italic;">"printString"</span>;
    nm[1].signature = <span style="color: #8fbc8f; font-style: italic;">"(Ljava/lang/String;)V"</span>;
    nm[1].fnPtr = (<span style="color: #9acd32; font-weight: bold;">void</span>*)printStringNative
</pre>



<p>
该部分代码用来将Java类的本地方法与JNI本地函数映射在一起。首先使用JNINativeMethod结构体数组，将待映射的本地方法与JNI本地函数的相关信息保存在数组中，而后调用RegisterNatives()函数进行映射。JNINativeMethod结构体定义如下
</p>


<pre class="src src-c">
<span style="color: #add8e6; font-weight: bold;">typedef</span> <span style="color: #add8e6; font-weight: bold;">struct</span> {
    <span style="color: #9acd32; font-weight: bold;">char</span> *<span style="color: #add8e6; font-weight: bold; font-style: italic;">name</span>;    <span style="color: #cccccc; font-style: italic;">// </span><span style="color: #cccccc; font-style: italic;">&#26412;&#22320;&#26041;&#27861;&#21517;&#31216;
</span>    <span style="color: #9acd32; font-weight: bold;">char</span> *<span style="color: #add8e6; font-weight: bold; font-style: italic;">signature</span>; <span style="color: #cccccc; font-style: italic;">// </span><span style="color: #cccccc; font-style: italic;">&#26412;&#22320;&#26041;&#27861;&#31614;&#21517;
</span>    <span style="color: #9acd32; font-weight: bold;">void</span> *<span style="color: #add8e6; font-weight: bold; font-style: italic;">fnPtr</span>; <span style="color: #cccccc; font-style: italic;">// </span><span style="color: #cccccc; font-style: italic;">&#19982;&#26412;&#22320;&#26041;&#27861;&#30456;&#23545;&#24212;&#30340;JNI&#26412;&#22320;&#20989;&#25968;&#25351;&#38024;
</span>} <span style="color: #add8e6; font-weight: bold; font-style: italic;">JNINativeMethod</span>
</pre>



<p>
如代码所示，nm是JNINativeMethod结构体数组，它保存着printHello()、printString()与printHelloNative()、printStringNative()函数的链接信息。
</p>
<p>
保存好映射信息后，将它们传递给RegisterNatives()函数，最后由RegisterNatives()函数完成映射。
</p><table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<col align="left"></col><col align="left"></col>
<thead>
<tr><th>JNI函数 RegisterNatives</th><th></th></tr>
</thead>
<tbody>
<tr><td>形式</td><td>jarray RegisterNatives(JNIEnv *env, jclass clazz, const JNINativeMethod *methdos, jint nMethods)</td></tr>
</tbody>
<tbody>
<tr><td>说明</td><td>将clazz指定类中的本地方法与JNI本地函数链接在一起，链接信息保存在JNINativeMethod结构体数组中</td></tr>
</tbody>
<tbody>
<tr><td>参数</td><td>env: JNI接口指针</td></tr>
<tr><td></td><td>clazz: Java类</td></tr>
<tr><td></td><td>methods: 包含本地方法与JNI本地函数的链接信息</td></tr>
<tr><td></td><td>nMethods: methods数组元素的个数</td></tr>
</tbody>
<tbody>
<tr><td>返回值</td><td>若执行成功，返回数组引用；否则返回NULL</td></tr>
</tbody>
</table>


<p>
<code>总结一下，本节中通过JNI_OnLoad()函数将Java本地方法与JNI本地函数映射起来。</code>
</p>
</div>

</div>

<div id="outline-container-4.2" class="outline-3">
<h3 id="sec-4.2">4.2 Android中的应用举例 </h3>
<div id="text-4.2">


</div>
</div>

</div>

<div id="outline-container-5" class="outline-2">
<h2 id="sec-5">5 使用Android NDK开发 </h2>
<div id="text-5">


<p>
Andoird NDK ( Native Development Kit )
</p>
<ul>
<li>
包含将C/C++源代码编译成本地库的工具(编译器、连接器等)

</li>
<li>
提供将编译好的本地库插入Android包文件(.apk)中的功能

</li>
<li>
在生成本地库时，Android平台可支持的系统头文件与库

</li>
<li>
NDK开发相关的文档、示例、规范

</li>
</ul>

</div>

<div id="outline-container-5.1" class="outline-3">
<h3 id="sec-5.1">5.1 安装Androdi NDK </h3>
<div id="text-5.1">


<p>
网站: <a href="http://developer.android.com/sdk/ndk/index.html">http://developer.android.com/sdk/ndk/index.html</a>
</p>
</div>

</div>

<div id="outline-container-5.2" class="outline-3">
<h3 id="sec-5.2">5.2 使用Android NDK 开发步骤 </h3>
<div id="text-5.2">


<p>
<code>设置好NDK环境变量后，在&lt;NDK_HOME&gt;/apps目录下，会看到一些NDK使用示例程序</code>
</p>
<ul>
<li>
hello-jni: 调用本地库，接收"Hello from JNI"字符串，并通过TextView将其输出

</li>
<li>
two-libs: 调用本地库，返回两数之和，并通过TextView输出

</li>
<li>
san-angeles: 调用本地OpenGL ES API， 渲染3D图片

</li>
<li>
hello-gl2: 调用OpenGL ES 2.0， 渲染三角形

</li>
<li>
bitmap-plasma: 一个使用本地代码访问Android Bitmap对象的像素缓存区的示例程序

</li>
</ul>
</div>

</div>

<div id="outline-container-5.3" class="outline-3">
<h3 id="sec-5.3">5.3 hello-jni </h3>
<div id="text-5.3">


<p>
内容：
</p>
<p>
AndroidManifest.xml default.properties /jni /res /src /tests
</p>
<p>
ndk-build后：
</p>
<p>
AndroidManifest.xml default.properties /jni /libs /obj /res /src /tests
</p>



<pre class="src src-sh">
hello-jni$ tree
<span style="color: #98fb98;">.</span>
&#9500;&#9472;&#9472; AndroidManifest.xml
&#9500;&#9472;&#9472; default.properties
&#9500;&#9472;&#9472; jni
&#9474;&#160;&#160; &#9500;&#9472;&#9472; Android.mk
&#9474;&#160;&#160; &#9492;&#9472;&#9472; hello-jni.c
&#9500;&#9472;&#9472; libs
&#9474;&#160;&#160; &#9492;&#9472;&#9472; armeabi
&#9474;&#160;&#160;     &#9500;&#9472;&#9472; gdbserver
&#9474;&#160;&#160;     &#9500;&#9472;&#9472; gdb.setup
&#9474;&#160;&#160;     &#9492;&#9472;&#9472; libhello-jni.so
&#9500;&#9472;&#9472; obj
&#9474;&#160;&#160; &#9492;&#9472;&#9472; local
&#9474;&#160;&#160;     &#9492;&#9472;&#9472; armeabi
&#9474;&#160;&#160;         &#9500;&#9472;&#9472; libhello-jni.so
&#9474;&#160;&#160;         &#9492;&#9472;&#9472; objs-debug
&#9474;&#160;&#160;             &#9492;&#9472;&#9472; hello-jni
&#9474;&#160;&#160;                 &#9500;&#9472;&#9472; hello-jni.o
&#9474;&#160;&#160;                 &#9492;&#9472;&#9472; hello-jni.o.d
&#9500;&#9472;&#9472; res
&#9474;&#160;&#160; &#9492;&#9472;&#9472; values
&#9474;&#160;&#160;     &#9492;&#9472;&#9472; strings.xml
&#9500;&#9472;&#9472; src
&#9474;&#160;&#160; &#9492;&#9472;&#9472; com
&#9474;&#160;&#160;     &#9492;&#9472;&#9472; example
&#9474;&#160;&#160;         &#9492;&#9472;&#9472; hellojni
&#9474;&#160;&#160;             &#9492;&#9472;&#9472; HelloJni.java
&#9492;&#9472;&#9472; tests
    &#9500;&#9472;&#9472; AndroidManifest.xml
    &#9500;&#9472;&#9472; default.properties
    &#9492;&#9472;&#9472; src
        &#9492;&#9472;&#9472; com
            &#9492;&#9472;&#9472; example
                &#9492;&#9472;&#9472; hellojni
                    &#9492;&#9472;&#9472; HelloJniTest.java

19 directories, 15 files
</pre>




<p>
关键的文件：
</p>
<p>
java层： HelloJni.java HelloJniTest.java 资源文件：strings.xml
</p>
<p>
jni层: hello-jni.c Android.mk
</p>
<p>
下面主要需要分析 HelloJni.java, hello-jni.c, Android.mk 三个文件
</p>
<p>
HelloJni.java
</p>


<pre class="src src-java">
<span style="color: #add8e6; font-weight: bold;">package</span> com.example.<span style="color: #add8e6;">hellojni</span>;

<span style="color: #add8e6; font-weight: bold;">import</span> <span style="color: #add8e6;">android</span>.<span style="color: #add8e6;">app</span>.<span style="color: #9acd32; font-weight: bold;">Activity</span>;
<span style="color: #add8e6; font-weight: bold;">import</span> <span style="color: #add8e6;">android</span>.<span style="color: #add8e6;">widget</span>.<span style="color: #9acd32; font-weight: bold;">TextView</span>;
<span style="color: #add8e6; font-weight: bold;">import</span> <span style="color: #add8e6;">android</span>.<span style="color: #add8e6;">os</span>.<span style="color: #9acd32; font-weight: bold;">Bundle</span>;

<span style="color: #add8e6; font-weight: bold;">public</span> <span style="color: #add8e6; font-weight: bold;">class</span> <span style="color: #9acd32; font-weight: bold;">HelloJni</span> <span style="color: #add8e6; font-weight: bold;">extends</span> <span style="color: #9acd32; font-weight: bold;">Activity</span>
{
    <span style="color: #8fbc8f; font-weight: bold;">/** onCreate&#20989;&#25968;&#22312;activity&#31532;&#19968;&#27425;&#34987;&#21019;&#24314;&#30340;&#26102;&#20505;&#35843;&#29992; */</span>
    @Override
    <span style="color: #add8e6; font-weight: bold;">public</span> <span style="color: #9acd32; font-weight: bold;">void</span> onCreate(<span style="color: #9acd32; font-weight: bold;">Bundle</span> <span style="color: #add8e6; font-weight: bold; font-style: italic;">savedInstanceState</span>)
    {
        <span style="color: #add8e6; font-weight: bold;">super</span>.onCreate(savedInstanceState);

        <span style="color: #cccccc; font-style: italic;">/* </span><span style="color: #cccccc; font-style: italic;">&#21019;&#24314;&#19968;&#20010;TextView&#24182;&#19988;&#35774;&#32622;&#23427;&#30340;&#20869;&#23481;.
         * &#25991;&#26412;&#30340;&#20869;&#23481;&#26159;&#36890;&#36807;&#26412;&#22320;&#26041;&#27861;&#33719;&#21462;&#30340;
         */</span>
        <span style="color: #9acd32; font-weight: bold;">TextView</span>  <span style="color: #add8e6; font-weight: bold; font-style: italic;">tv</span> = <span style="color: #add8e6; font-weight: bold;">new</span> <span style="color: #9acd32; font-weight: bold;">TextView</span>(<span style="color: #add8e6; font-weight: bold;">this</span>);
        tv.setText( stringFromJNI() ); <span style="color: #cccccc; font-style: italic;">// </span><span style="color: #cccccc; font-style: italic;">&#36825;&#37324;&#35843;&#29992;&#20102;&#26412;&#22320;&#26041;&#27861;
</span>        setContentView(tv);
    }

    <span style="color: #cccccc; font-style: italic;">/* </span><span style="color: #cccccc; font-style: italic;">&#26412;&#22320;&#26041;&#27861;&#36890;&#36807;&#26412;&#22320;&#24211;hello-jni&#23454;&#29616;
     * &#26412;&#22320;&#24211;&#19982;&#36825;&#20010;&#24212;&#29992;&#31243;&#24207;&#24050;&#32463;&#25171;&#21253;&#22312;&#20102;&#19968;&#36215;
     */</span>
    <span style="color: #add8e6; font-weight: bold;">public</span> <span style="color: #add8e6; font-weight: bold;">native</span> <span style="color: #9acd32; font-weight: bold;">String</span>  <span style="color: #ffff00; font-weight: bold; font-style: italic;">stringFromJNI</span>();

    <span style="color: #cccccc; font-style: italic;">/* </span><span style="color: #cccccc; font-style: italic;">&#19979;&#38754;&#26159;&#21478;&#22806;&#19968;&#20010;&#26041;&#27861;&#30340;&#22768;&#26126;&#65292;&#36825;&#20010;&#26041;&#27861;&#27809;&#26377;&#36890;&#36807;hello-jni&#23454;&#29616;
     * &#36825;&#26159;&#20026;&#20102;&#35828;&#26126;&#65292;&#20320;&#21487;&#20197;&#22768;&#26126;&#20219;&#24847;&#30340;&#26412;&#22320;&#26041;&#27861;&#65292;&#22312;java&#20195;&#30721;&#20013;
     * &#23427;&#20204;&#30340;&#23454;&#29616;&#20250;&#22312;&#35013;&#36733;&#30340;&#26412;&#22320;&#24211;&#37324;&#23547;&#25214;&#65292;&#24403;&#20320;&#39318;&#27425;&#35843;&#29992;&#23427;&#20204;&#30340;&#26102;&#20505;
     * &#23581;&#35797;&#35843;&#29992;&#36825;&#20010;&#26041;&#27861;&#20250;&#24341;&#21457;java.lang.UnsatisfiedLinkError exception!
     */</span>
    <span style="color: #add8e6; font-weight: bold;">public</span> <span style="color: #add8e6; font-weight: bold;">native</span> <span style="color: #9acd32; font-weight: bold;">String</span>  <span style="color: #ffff00; font-weight: bold; font-style: italic;">unimplementedStringFromJNI</span>();

    <span style="color: #cccccc; font-style: italic;">/* </span><span style="color: #cccccc; font-style: italic;">&#19979;&#38754;&#30340;&#20195;&#30721;&#29992;&#26469;&#22312;&#24212;&#29992;&#31243;&#24207;&#24320;&#22987;&#30340;&#26102;&#20505;&#35013;&#36733;hello-jni&#24211;
     * &#36825;&#20010;&#24211;&#22312;&#23433;&#35013;&#30340;&#26102;&#20505;&#30001;&#21253;&#31649;&#29702;&#22120;&#24050;&#32463;&#23433;&#35013;&#22909;&#20102;
     */</span>
    <span style="color: #add8e6; font-weight: bold;">static</span> {
        System.loadLibrary(<span style="color: #8fbc8f; font-style: italic;">"hello-jni"</span>);
    }
}
</pre>




<p>
hello-jni.c
</p>


<pre class="src src-c">
<span style="color: #0000cd;">#include</span> <span style="color: #8fbc8f; font-style: italic;">&lt;string.h&gt;</span>
<span style="color: #0000cd;">#include</span> <span style="color: #8fbc8f; font-style: italic;">&lt;jni.h&gt;</span>
<span style="color: #9acd32; font-weight: bold;">jstring</span> <span style="color: #ffff00; font-weight: bold; font-style: italic;">java_com_example_hellojni_HelloJni_stringFromJNI</span>(<span style="color: #9acd32; font-weight: bold;">JNIEnv</span> *<span style="color: #add8e6; font-weight: bold; font-style: italic;">env</span>, <span style="color: #9acd32; font-weight: bold;">jobject</span> <span style="color: #add8e6; font-weight: bold; font-style: italic;">thiz</span>)
{
    <span style="color: #add8e6; font-weight: bold;">return</span> (*env)-&gt;NewStringUTF(env, <span style="color: #8fbc8f; font-style: italic;">"Hello from JNI !"</span>);
}
</pre>




<p>
Android.mk
</p>


<pre class="src src-sh">
LOCAL_PATH := $(<span style="color: #fa8072;">call</span> my-dir)

include $(<span style="color: #fa8072;">CLEAR_VARS</span>)

LOCAL_MODULE := hello-jni
LOCALSRC_FILES := hello-jni.c

include $(<span style="color: #fa8072;">BUILD_SHARED_LIBRARY</span>)
</pre>




<p>
一个Android.mk文件首先必须定义好 <code>LOCAL_PATH</code> 变量，用于在开发树中查找源文件。 <code>LOCAL_PATH</code> 变量在Android.mk文件的最开始被定义，若无特殊情况，一般采用如下编写形式：
</p>


<pre class="src src-sh">
LOCAL_PATH := $(<span style="color: #fa8072;">call</span> my-dir)
</pre>



<p>
$(call my-dir)用来保存my-dir宏函数的返回值。my-dir是一个宏函数，由编译系统提供，用于返回包含Android.mk文件的目录，即将Android.mk文件所在的目录设置为基本目录。
</p>
<p>
一般来说，本地库的源代码与Android.mk文件在同一目录下，即在 <code>&lt;PROJECT_HOME&gt;/jni</code> 目录下。若将$(call my-dir)返回值保存到 <code>LOCAL_PATH</code> 变量中，即可准确指定NDK编译的基本文件目录。
</p>
<p>
<code>include $(CLEAR_VARS)</code> 用来初始化Android.mk文件中" <code>LOCAL_XXX</code> "即以 <code>LOCAL_</code> 开头的变量，如 <code>LOCAL_MODULE</code> 、 <code>LOCAL_SRC_FILES</code> 等变量，但在一开始的 <code>LOCAL_PATH</code> 变量除外。由于Android编译系统将会 <code>LOCAL_XXX</code> 变量用作全局变量，所以需要使用该命令初始化这些变量。
</p>
<p>
<code>LOCAL_MODULE</code> 变量必须被定义，以标识在Android.mk文件中描述的每个模块，即要生成的库的名称。该名称必须唯一，且不含空格，编译系统会自动产生合适的前缀和后缀，比如设置 <code>LOCAL_MODULE</code> 变量为ndk-exam, 编译后缀会生成名为libndk-exam.so的共享库。
</p>
<p>
<code>LOCAL_SRC_FILES</code> 变量必须包含将要编译打包进模块中的各个源文件。这些源文件所在目录即是 <code>LOCAL_PATH</code> 变量指定的目录，即 <code>&lt;PROJECT_HOME&gt;/jni</code> 目录。
</p>
<p>
<code>include $(BUILD_SHARED_LIBRARY)</code> 使用 <code>LOCAL_MODULE</code> 、 <code>LOCAL_SRC_FILES</code> 等变量值，创建名称为 <code>lib$(LOCAL_MODULE).so</code> 的共享库。
</p>

</div>
</div>
</div>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">
<p class="footnote"><sup><a class="footnum" name="fn.1" href="#fnr.1">1</a></sup> FOOTNOTE DEFINITION NOT FOUND: 0
</p>
</div>
</div>
<div id="postamble"><p class="author"> Author: Wizard.Yang
<a href="mailto:xblandy@gmail.com">&lt;xblandy@gmail.com&gt;</a>
</p>
<p class="date"> Date: 2012-08-01 11:05:22 CST</p>
</div></body>
</html>
