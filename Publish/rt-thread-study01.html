<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
               "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"
lang="en" xml:lang="en">
<head>
<title>rt-thread之realtouch 学习笔记 01</title>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
<meta name="generator" content="Org-mode"/>
<meta name="generated" content="2012-09-10 14:10:12 CST"/>
<meta name="author" content="Wizard.Yang"/>
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  html { font-family: Times, serif; font-size: 12pt; }
  .title  { text-align: center; }
  .todo   { color: red; }
  .done   { color: green; }
  .tag    { background-color:lightblue; font-weight:normal }
  .target { }
  .timestamp { color: grey }
  .timestamp-kwd { color: CadetBlue }
  p.verse { margin-left: 3% }
  pre {
	border: 1pt solid #AEBDCC;
	background-color: #F3F5F7;
	padding: 5pt;
	font-family: courier, monospace;
        font-size: 90%;
        overflow:auto;
  }
  table { border-collapse: collapse; }
  td, th { vertical-align: top; }
  dt { font-weight: bold; }
  div.figure { padding: 0.5em; }
  div.figure p { text-align: center; }
  .linenr { font-size:smaller }
  .code-highlighted {background-color:#ffff00;}
  .org-info-js_info-navigation { border-style:none; }
  #org-info-js_console-label { font-size:10px; font-weight:bold;
                               white-space:nowrap; }
  .org-info-js_search-highlight {background-color:#ffff00; color:#000000;
                                 font-weight:bold; }
  /*]]>*/-->
</style>
<script type="text/javascript">
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*/-->
</script>
</head><body>
<h1 class="title">rt-thread之realtouch 学习笔记 01</h1>

<p>记录学习过程中的点点滴滴
</p>


<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1 开发环境的搭建 </a></li>
<li><a href="#sec-2">2 开始研究代码的目录结构 </a>
<ul>
<li>
<ul>
<li><a href="#sec-2.1">2.1 <code>rt_hw_board_init()</code> </a></li>
<li><a href="#sec-2.2">2.2 <code>void rt_show_version(void)</code> </a></li>
<li><a href="#sec-2.3">2.3 <code>void rt_system_tick_init(void)</code> </a></li>
<li><a href="#sec-2.4">2.4 <code>void rt_system_object_init(void)</code> </a></li>
<li><a href="#sec-2.5">2.5 <code>void rt_system_timer_init(void)</code> </a></li>
<li><a href="#sec-2.6">2.6 <code>void rt_system_scheduler_init(void)</code> </a></li>
<li><a href="#sec-2.7">2.7 <code>rt_device_init_all()</code> <code>rt_application_init()</code> </a></li>
<li><a href="#sec-2.8">2.8 <code>rt_system_timer_thread_init()</code> </a></li>
<li><a href="#sec-2.9">2.9 <code>rt_thread_idle_init()</code> </a></li>
<li><a href="#sec-2.10">2.10 <code>rt_system_scheduler_start()</code> </a></li>
</ul></li>
</ul>
</li>
<li><a href="#sec-3">3 优先级探索 </a></li>
<li><a href="#sec-4">4 发现DEBUG </a></li>
<li><a href="#sec-5">5 定时器 SysTick </a></li>
<li><a href="#sec-6">6 线程 优先级 </a>
<ul>
<li><a href="#sec-6.1">6.1 <code>RT_THREAD_INIT</code> </a></li>
<li><a href="#sec-6.2">6.2 <code>RT_THREAD_READY</code> </a></li>
<li><a href="#sec-6.3">6.3 <code>RT_THREAD_SUSPEND</code> </a></li>
<li><a href="#sec-6.4">6.4 <code>RT_THREAD_RUNNING</code> </a></li>
<li><a href="#sec-6.5">6.5 <code>RT_THREAD_BLOCK</code> </a></li>
<li><a href="#sec-6.6">6.6 <code>RT_THREAD_CLOSE</code> </a></li>
<li><a href="#sec-6.7">6.7 kernel如何找到当前优先级最高的线程的 </a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-1" class="outline-2">
<h2 id="sec-1">1 开发环境的搭建 </h2>
<div id="text-1">


<p>
推荐开发使用操作系统:Window系列。目前仅尝试过WindowXP。
推荐原因：因为我要使用JLINK进行程序的烧录，而JLINK的Linux驱动是无法在盗版JLINK上使用的。
</p>
<p>
使用开发IDE：MDK ARM。
版本：4.12是不行的，要用新的，因为老版本不支持新的CPU架构。我使用的是v4.54。
说明：新的MDK的JLINK驱动会要求更新JLINK固件，SEGGER官网上的新固件会识别盗版JLINK。因此不建议更新。
</p>
<p>
使用JLINK驱动：J-Link ARM V4.40c
原因：最新的驱动程序会检查盗版JLINK从而退出程序，太老的驱动又不支持新的CPU架构。
</p>
<p>
使用交叉编译工具链：arm-2011.03-42-arm-none-eabi.exe
安装默认在C盘，使用gcc编译。
</p>
<p>
使用python版本： python-2.7.1.msi
</p>
<p>
使用scons版本：scons-2.2.0-setup.exe
</p>
<p>
说明：gcc+python+scons就可以完成编译工作，Keil是作为开发IDE来使用的，使用Keil的时候我不确信是否使用的是gcc的工具链。也不确认是否会用到python和scons。
</p>
<p>
软件安装完毕之后，下载rt-thread realtouch的代码，解压。
</p><ul>
<li>
bin
</li>
<li>
programs
</li>
<li>
realtouch
</li>
<li>
sdcard
</li>
<li>
README.txt
</li>
</ul>

<p>得到上面的目录结构。
</p>
<p>
我推荐使用github.com上的for windows软件来管理代码，觉得git挺好用的。
</p>
<p>
进入realtouch目录，打开project.uvproj，Keil打开了整个工程。
</p>
<p>
build，没有error，有warning。
</p>
<p>
更改Keil设置：
</p>
<p>
Target Options&hellip; -&gt; Debug-&gt; Use J-LINK/J-Trace Cortex Settings-&gt; 选择SW模式
</p>
<p>
Target Options&hellip; -&gt; Utilities-&gt;Settings-&gt;Programming Algorithm选择Add STM32F4xx Flash 1M的算法
</p>
<p>
然后连接JLINK和realtouch板，应该就能正常的烧录了。
</p>
<p>
我也试过用scons编译完了之后，用J-Link ARM把rtthread.bin文件烧录进去，主要需要选择好CPU的类型。
</p>
<p>
烧写过程中realtouch需要在外接电源上电状态。
</p>
<p>
烧写完毕，程序启动，触摸屏校准程序启动。接上串口板，串口上有输出信息。
</p>
<p>
至此，表明，基本的开发环境搭建完毕。
</p>
</div>

</div>

<div id="outline-container-2" class="outline-2">
<h2 id="sec-2">2 开始研究代码的目录结构 </h2>
<div id="text-2">


<p>
首先要看的是Keil的Project窗口，里面列出了为划分层次而人为建立的目录结构：
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<col align="left"></col>
<thead>
<tr><th>RTThread</th></tr>
</thead>
<tbody>
<tr><td><code>Applications</code></td></tr>
<tr><td><code>Drivers</code></td></tr>
<tr><td><code>STM32_StdPeriph</code></td></tr>
<tr><td><code>ui</code></td></tr>
<tr><td><code>Kernel</code></td></tr>
<tr><td><code>CORTEX-M4</code></td></tr>
<tr><td><code>Filesystem</code></td></tr>
<tr><td><code>DeviceDrivers</code></td></tr>
<tr><td><code>jpeg</code></td></tr>
<tr><td><code>finsh</code></td></tr>
<tr><td><code>Components</code></td></tr>
<tr><td><code>LwIP</code></td></tr>
<tr><td><code>pthreads</code></td></tr>
<tr><td><code>RTGUI</code></td></tr>
<tr><td></td></tr>
</tbody>
</table>


<p>
打开各个折叠的目录看了一下,主要关注两个目录: <code>Application</code> 和 <code>STM32_StdPeriph</code>
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<col align="left"></col>
<thead>
<tr><th><code>Application</code></th></tr>
</thead>
<tbody>
<tr><td><code>application.c</code></td></tr>
<tr><td><code>libc_export.c</code></td></tr>
<tr><td><code>setup.c</code></td></tr>
<tr><td><code>startup.c</code></td></tr>
<tr><td></td></tr>
</tbody>
</table>


<p>
在startup.c中有着C语言的入口函数main()
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<col align="left"></col>
<thead>
<tr><th><code>STM32_StdPeriph</code></th></tr>
</thead>
<tbody>
<tr><td><code>system_stm32f4xx.c</code></td></tr>
<tr><td><code>startup_stm32f4xx.s</code></td></tr>
<tr><td></td></tr>
</tbody>
</table>


<p>
<code>startup_stm32f4x.s</code> 文件里面是汇编代码,是最开始的程序。
</p>
<p>
下面看一下汇编里面的关键代码
</p>



<pre class="src src-asm">
<span style="color: #cccccc; font-style: italic;">; </span><span style="color: #cccccc; font-style: italic;">Reset handler
</span><span style="color: #ffff00; font-weight: bold; font-style: italic;">Reset_Handler</span> <span style="color: #add8e6; font-weight: bold;">PROC</span>
              <span style="color: #add8e6; font-weight: bold;">EXPORT</span> Reset_Handler [WEAK]
      <span style="color: #add8e6; font-weight: bold;">IMPORT</span>  SystemInit
      <span style="color: #add8e6; font-weight: bold;">IMPORT</span>  __main
           
              <span style="color: #add8e6; font-weight: bold;">LDR</span>    R0, =SystemInit
              <span style="color: #add8e6; font-weight: bold;">BLX</span>    R0
              <span style="color: #add8e6; font-weight: bold;">LDR</span>    R0, =__main
              <span style="color: #add8e6; font-weight: bold;">BX</span>     R0
              <span style="color: #add8e6; font-weight: bold;">ENDP</span>
</pre>




<p>
系统在复位之后，调用了两个函数。
</p>



<pre class="src src-c">
<span style="color: #8fbc8f; font-weight: bold;">/**
  * </span><span style="color: #add8e6; font-weight: bold;">@brief</span><span style="color: #8fbc8f; font-weight: bold;">  Setup the microcontroller system
  *         Initialize the Embedded Flash Interface, the PLL and update the 
  *         SystemFrequency variable.
  *         &#35774;&#32622;MCU&#65292;&#21021;&#22987;&#21270;&#23884;&#20837;&#24335;Flash&#25509;&#21475;&#65292;PLL&#21644;&#21319;&#32423;&#31995;&#32479;&#26102;&#38047;&#39057;&#29575;&#21464;&#37327;
  * </span><span style="color: #add8e6; font-weight: bold;">@param</span><span style="color: #8fbc8f; font-weight: bold;">  None
  * </span><span style="color: #add8e6; font-weight: bold;">@retval</span><span style="color: #8fbc8f; font-weight: bold;"> None
  */</span>

<span style="color: #9acd32; font-weight: bold;">void</span> <span style="color: #ffff00; font-weight: bold; font-style: italic;">SystemInit</span>(<span style="color: #9acd32; font-weight: bold;">void</span>)
{
  <span style="color: #cccccc; font-style: italic;">/* </span><span style="color: #cccccc; font-style: italic;">FPU settings &#35774;&#32622;FPU </span><span style="color: #cccccc; font-style: italic;">*/</span>
<span style="color: #0000cd;">  #if</span> (__FPU_PRESENT == 1) &amp;&amp; (__FPU_USED == 1)
    SCB-&gt;CPACR |= ((3UL &lt;&lt; 10*2)|(3UL &lt;&lt; 11*2));  <span style="color: #cccccc; font-style: italic;">/* </span><span style="color: #cccccc; font-style: italic;">set CP10 and CP11 Full Access CPACR:&#21327;&#22788;&#29702;&#22120;&#35775;&#38382;&#25511;&#21046;&#23492;&#23384;&#22120; </span><span style="color: #cccccc; font-style: italic;">*/</span>
<span style="color: #cccccc; font-style: italic;">/*</span><span style="color: #cccccc; font-style: italic;">
0b00: &#25298;&#32477;&#35775;&#38382;.&#20219;&#20309;&#35775;&#38382;&#23581;&#35797;&#37117;&#20250;&#20135;&#29983;&#19968;&#20010;NOCP&#30340;UsageFault.
0b01: &#20248;&#20808;&#32423;&#35775;&#38382;.&#38750;&#20248;&#20808;&#32423;&#35775;&#38382;&#20135;&#29983;&#19968;&#20010;NOCP fault.
0b10: &#20445;&#30041;.&#35775;&#38382;&#30340;&#32467;&#26524;&#26410;&#39044;&#26399;
0b11: &#20840;&#35775;&#38382;
</span><span style="color: #cccccc; font-style: italic;">*/</span>
<span style="color: #0000cd;">  #endif</span>

  <span style="color: #cccccc; font-style: italic;">/* </span><span style="color: #cccccc; font-style: italic;">Reset the RCC clock configuration to the default reset state 
     &#22797;&#20301;RCC&#26102;&#38047;&#37197;&#32622;&#20026;&#22797;&#20301;&#21518;&#40664;&#35748;&#29366;&#24577; </span><span style="color: #cccccc; font-style: italic;">*/</span>

  <span style="color: #cccccc; font-style: italic;">/* </span><span style="color: #cccccc; font-style: italic;">Set HSION bit &#20869;&#37096;&#39640;&#36895;&#26102;&#38047;&#20351;&#33021;</span><span style="color: #cccccc; font-style: italic;">*/</span>
  RCC-&gt;CR |= (<span style="color: #9acd32; font-weight: bold;">uint32_t</span>)0x00000001;

  <span style="color: #cccccc; font-style: italic;">/* </span><span style="color: #cccccc; font-style: italic;">Reset CFGR register &#26102;&#38047;&#37197;&#32622;&#23492;&#23384;&#22120; </span><span style="color: #cccccc; font-style: italic;">*/</span>
  RCC-&gt;CFGR = 0x00000000;

  <span style="color: #cccccc; font-style: italic;">/* </span><span style="color: #cccccc; font-style: italic;">Reset HSEON, CSSON and PLLON bits </span><span style="color: #cccccc; font-style: italic;">*/</span>
  RCC-&gt;CR &amp;= (<span style="color: #9acd32; font-weight: bold;">uint32_t</span>)0xFEF6FFFF;

  <span style="color: #cccccc; font-style: italic;">/* </span><span style="color: #cccccc; font-style: italic;">Reset PLLCFGR register </span><span style="color: #cccccc; font-style: italic;">*/</span>
  RCC-&gt;PLLCFGR = 0x24003010;

  <span style="color: #cccccc; font-style: italic;">/* </span><span style="color: #cccccc; font-style: italic;">Reset HSEBYP bit </span><span style="color: #cccccc; font-style: italic;">*/</span>
  RCC-&gt;CR &amp;= (<span style="color: #9acd32; font-weight: bold;">uint32_t</span>)0xFFFBFFFF;

  <span style="color: #cccccc; font-style: italic;">/* </span><span style="color: #cccccc; font-style: italic;">Disable all interrupts &#26102;&#38047;&#20013;&#26029;&#23492;&#23384;&#22120; </span><span style="color: #cccccc; font-style: italic;">*/</span>
  RCC-&gt;CIR = 0x00000000;

<span style="color: #0000cd;">#ifdef</span> DATA_IN_ExtSRAM
  SystemInit_ExtMemCtl();
<span style="color: #0000cd;">#endif</span> <span style="color: #cccccc; font-style: italic;">/* </span><span style="color: #cccccc; font-style: italic;">DATA_IN_ExtSRAM </span><span style="color: #cccccc; font-style: italic;">*/</span>

  <span style="color: #cccccc; font-style: italic;">/* </span><span style="color: #cccccc; font-style: italic;">Configure the System clock source, PLL Multiplier and Divider factors, 
     AHB/APBx prescalers and Flash settings ----------------------------------</span><span style="color: #cccccc; font-style: italic;">*/</span>
  SetSysClock();

  <span style="color: #cccccc; font-style: italic;">/* </span><span style="color: #cccccc; font-style: italic;">Configure the Vector Table location add offset address ------------------</span><span style="color: #cccccc; font-style: italic;">*/</span>
<span style="color: #0000cd;">#ifdef</span> VECT_TAB_SRAM
  SCB-&gt;VTOR = SRAM_BASE | VECT_TAB_OFFSET; <span style="color: #cccccc; font-style: italic;">/* </span><span style="color: #cccccc; font-style: italic;">Vector Table Relocation in Internal SRAM </span><span style="color: #cccccc; font-style: italic;">*/</span>
<span style="color: #0000cd;">#else</span>
  SCB-&gt;VTOR = FLASH_BASE | VECT_TAB_OFFSET; <span style="color: #cccccc; font-style: italic;">/* </span><span style="color: #cccccc; font-style: italic;">Vector Table Relocation in Internal FLASH </span><span style="color: #cccccc; font-style: italic;">*/</span>
<span style="color: #0000cd;">#endif</span>
}

</pre>





<pre class="src src-c">

<span style="color: #9acd32; font-weight: bold;">int</span> <span style="color: #ffff00; font-weight: bold; font-style: italic;">main</span>(<span style="color: #9acd32; font-weight: bold;">void</span>)
{
    <span style="color: #cccccc; font-style: italic;">/* </span><span style="color: #cccccc; font-style: italic;">disable interrupt first </span><span style="color: #cccccc; font-style: italic;">*/</span>
    rt_hw_interrupt_disable();

    <span style="color: #cccccc; font-style: italic;">/* </span><span style="color: #cccccc; font-style: italic;">startup RT-Thread RTOS </span><span style="color: #cccccc; font-style: italic;">*/</span>
    rtthread_startup();

    <span style="color: #add8e6; font-weight: bold;">return</span> 0;

</pre>




<p>
关注 <code>rtthread_startup()</code> 函数，就在startup.c中，这是rt-thread的入口。
</p>


<pre class="src src-c">
<span style="color: #cccccc; font-style: italic;">/*</span><span style="color: #cccccc; font-style: italic;">This function will startup RT-Thread RTOS.</span><span style="color: #cccccc; font-style: italic;">*/</span>
<span style="color: #9acd32; font-weight: bold;">void</span> <span style="color: #ffff00; font-weight: bold; font-style: italic;">rtthread_startup</span>(<span style="color: #9acd32; font-weight: bold;">void</span>)
{
    <span style="color: #cccccc; font-style: italic;">/*</span><span style="color: #cccccc; font-style: italic;">init board</span><span style="color: #cccccc; font-style: italic;">*/</span>
    rt_hw_board_init();

    <span style="color: #cccccc; font-style: italic;">/*</span><span style="color: #cccccc; font-style: italic;">show version</span><span style="color: #cccccc; font-style: italic;">*/</span>
    rt_show_version();
    
    <span style="color: #cccccc; font-style: italic;">/*</span><span style="color: #cccccc; font-style: italic;">init tick</span><span style="color: #cccccc; font-style: italic;">*/</span>
    rt_system_tick_init();

    <span style="color: #cccccc; font-style: italic;">/*</span><span style="color: #cccccc; font-style: italic;">init kernel object</span><span style="color: #cccccc; font-style: italic;">*/</span>
    rt_system_object_init();

    <span style="color: #cccccc; font-style: italic;">/*</span><span style="color: #cccccc; font-style: italic;">init timer system</span><span style="color: #cccccc; font-style: italic;">*/</span>
    rt_system_timer_init();

<span style="color: #0000cd;">#if</span> STM32_EXT_SRAM
    ext_sram_init();
    rt_system_heap_init((<span style="color: #9acd32; font-weight: bold;">void</span>*)STM32_EXT_SRAM_BEGIN,
                        (<span style="color: #9acd32; font-weight: bold;">void</span>*)STM32_EXT_SRAM_END);
<span style="color: #0000cd;">#else</span>
    rt_system_heap_init((<span style="color: #9acd32; font-weight: bold;">void</span>*)STM32_SRAM_BEGIN, (<span style="color: #9acd32; font-weight: bold;">void</span>*)STM32_SRAM_END);
<span style="color: #0000cd;">#endif</span> <span style="color: #cccccc; font-style: italic;">/* </span><span style="color: #cccccc; font-style: italic;">STM32_EXT_SRAM </span><span style="color: #cccccc; font-style: italic;">*/</span>

    <span style="color: #cccccc; font-style: italic;">/* </span><span style="color: #cccccc; font-style: italic;">init scheduler system </span><span style="color: #cccccc; font-style: italic;">*/</span>
    rt_system_scheduler_init();

    <span style="color: #cccccc; font-style: italic;">/* </span><span style="color: #cccccc; font-style: italic;">init all device </span><span style="color: #cccccc; font-style: italic;">*/</span>
    rt_device_init_all();

    <span style="color: #cccccc; font-style: italic;">/*</span><span style="color: #cccccc; font-style: italic;">init application</span><span style="color: #cccccc; font-style: italic;">*/</span>
    rt_application_init();

    <span style="color: #cccccc; font-style: italic;">/*</span><span style="color: #cccccc; font-style: italic;">init timer thread</span><span style="color: #cccccc; font-style: italic;">*/</span>
    rt_system_timer_thread_init();

    <span style="color: #cccccc; font-style: italic;">/*</span><span style="color: #cccccc; font-style: italic;">init idle thread</span><span style="color: #cccccc; font-style: italic;">*/</span>
    rt_thread_idle_init();

    <span style="color: #cccccc; font-style: italic;">/*</span><span style="color: #cccccc; font-style: italic;">start scheduler</span><span style="color: #cccccc; font-style: italic;">*/</span>
    rt_system_scheduler_start();

    <span style="color: #cccccc; font-style: italic;">/*</span><span style="color: #cccccc; font-style: italic;">never reach here</span><span style="color: #cccccc; font-style: italic;">*/</span>
    <span style="color: #add8e6; font-weight: bold;">return</span>;
}
</pre>




<p>
这段代码做了不少的事情，而且每一个事情的背后都隐藏着很多的知识储备。
</p><ul>
<li>
初始化板子
</li>
<li>
打印版本信息
</li>
<li>
初始化tick
</li>
<li>
初始化内核对象
</li>
<li>
初始化定时器系统
</li>
<li>
初始化外部SRAM(在定义的情况下)
</li>
<li>
初始化调度系统
</li>
<li>
初始化所有的设备
</li>
<li>
初始化应用程序
</li>
<li>
初始化定时器线程
</li>
<li>
初始化空闲进程
</li>
<li>
开始调度

</li>
</ul>

<p>上面这些，大部分还都是与内核紧密相连的，没什么办法，一个一个的看看
</p>

</div>

<div id="outline-container-2.1" class="outline-4">
<h4 id="sec-2.1">2.1 <code>rt_hw_board_init()</code> </h4>
<div id="text-2.1">




<pre class="src src-c">
<span style="color: #cccccc; font-style: italic;">/*</span><span style="color: #cccccc; font-style: italic;">This function will initial STM32 board.</span><span style="color: #cccccc; font-style: italic;">*/</span>
<span style="color: #9acd32; font-weight: bold;">void</span> <span style="color: #ffff00; font-weight: bold; font-style: italic;">rt_hw_board_init</span>()
{
    <span style="color: #cccccc; font-style: italic;">/*</span><span style="color: #cccccc; font-style: italic;">NVIC Configuration &#35774;&#32622;&#20013;&#26029;&#21521;&#37327;&#34920;</span><span style="color: #cccccc; font-style: italic;">*/</span>
    NVIC_Configurationa();

    <span style="color: #cccccc; font-style: italic;">/*</span><span style="color: #cccccc; font-style: italic;">Configure the SysTick &#37197;&#32622;&#31995;&#32479;tick&#23450;&#26102;&#22120;&#21644;&#23427;&#30340;&#20013;&#26029;&#65292;&#24182;&#19988;&#21551;&#21160;tick&#23450;&#26102;&#22120;</span><span style="color: #cccccc; font-style: italic;">*/</span>
    SysTick_Config(SystemCoreClock/RT_TICK_PER_SECOND);

    rt_hw_usart_init();<span style="color: #cccccc; font-style: italic;">/*</span><span style="color: #cccccc; font-style: italic;">&#26681;&#25454;&#23450;&#20041;&#30340;&#23439;&#65292;&#37197;&#32622;&#23545;&#24212;&#30340;&#20018;&#21475;&#65292;&#24182;&#19988;&#27880;&#20876;&#20102;UART1</span><span style="color: #cccccc; font-style: italic;">*/</span>
<span style="color: #0000cd;">#ifdef</span> RT_USING_CONSOLE
    rt_console_set_device(RT_CONSOLE_DEVICE_NAME);<span style="color: #cccccc; font-style: italic;">/*</span><span style="color: #cccccc; font-style: italic;">&#35774;&#32622;&#19968;&#20010;&#35774;&#22791;&#20316;&#20026;&#25511;&#21046;&#21488;&#35774;&#22791;&#12290;&#25152;&#26377;&#30340;&#36755;&#20986;&#37117;&#20250;&#34987;&#37325;&#23450;&#21521;&#21040;&#36825;&#20010;&#35774;&#22791;</span><span style="color: #cccccc; font-style: italic;">*/</span>
<span style="color: #0000cd;">#endif</span>

    fsmc_gpio_init();<span style="color: #cccccc; font-style: italic;">/*</span><span style="color: #cccccc; font-style: italic;">&#37197;&#32622;&#28082;&#26230;&#23631;&#25511;&#21046;&#22120;</span><span style="color: #cccccc; font-style: italic;">*/</span>

    mco_config();<span style="color: #cccccc; font-style: italic;">/*</span><span style="color: #cccccc; font-style: italic;">&#37197;&#32622;&#26230;&#25391;</span><span style="color: #cccccc; font-style: italic;">*/</span>
}
</pre>




</div>

</div>

<div id="outline-container-2.2" class="outline-4">
<h4 id="sec-2.2">2.2 <code>void rt_show_version(void)</code> </h4>
<div id="text-2.2">


<p>
这个函数就是用 <code>rt_kprintf</code> 打印了一些信息。
</p>
</div>

</div>

<div id="outline-container-2.3" class="outline-4">
<h4 id="sec-2.3">2.3 <code>void rt_system_tick_init(void)</code> </h4>
<div id="text-2.3">


<p>
这个函数在新的版本中不使用了
</p>
</div>

</div>

<div id="outline-container-2.4" class="outline-4">
<h4 id="sec-2.4">2.4 <code>void rt_system_object_init(void)</code> </h4>
<div id="text-2.4">


<p>
这个函数在新的版本中不使用了
</p>
</div>

</div>

<div id="outline-container-2.5" class="outline-4">
<h4 id="sec-2.5">2.5 <code>void rt_system_timer_init(void)</code> </h4>
<div id="text-2.5">


<p>
这个函数在新的版本中不使用了
</p>
</div>

</div>

<div id="outline-container-2.6" class="outline-4">
<h4 id="sec-2.6">2.6 <code>void rt_system_scheduler_init(void)</code> </h4>
<div id="text-2.6">


<p>
这个函数将会初始化系统调度器
</p>


<pre class="src src-c">
<span style="color: #9acd32; font-weight: bold;">void</span> <span style="color: #ffff00; font-weight: bold; font-style: italic;">rt_system_scheduler_init</span>(<span style="color: #9acd32; font-weight: bold;">void</span>)
{
    <span style="color: #add8e6; font-weight: bold;">register</span> <span style="color: #9acd32; font-weight: bold;">rt_base_t</span> <span style="color: #add8e6; font-weight: bold; font-style: italic;">offset</span>;

    rt_scheduler_lock_nest = 0;

    RT_DEBUG_LOG(RT_DEBUG_SCHEDULER, 
      (<span style="color: #8fbc8f; font-style: italic;">"start scheduler: max priority 0X%02x\n"</span>, RT_THREAD_PRIORITY_MAX));

    <span style="color: #add8e6; font-weight: bold;">for</span> (offset = 0; offset &lt; RT_THREAD_PRIORITY_MAX; offset++) {
        rt_list_init(&amp;rt_thread_priority_table[offset]);
    }

    rt_current_priority = RT_THREAD_PRIORITY_MAX - 1;
    rt_current_thread = RT_NULL;

    <span style="color: #cccccc; font-style: italic;">/*</span><span style="color: #cccccc; font-style: italic;">initialize ready priority group</span><span style="color: #cccccc; font-style: italic;">*/</span>
    rt_thread_ready_priority_group = 0;

<span style="color: #0000cd;">#if</span> RT_THREAD_PRIORITY_MAX &gt; 32
    <span style="color: #cccccc; font-style: italic;">/*</span><span style="color: #cccccc; font-style: italic;">initialize ready table </span><span style="color: #cccccc; font-style: italic;">*/</span>
    rt_memset(rt_thread_ready_table, 0, <span style="color: #add8e6; font-weight: bold;">sizeof</span>(rt_thread_ready_table));
<span style="color: #0000cd;">#endif</span>

    <span style="color: #cccccc; font-style: italic;">/*</span><span style="color: #cccccc; font-style: italic;">initialize thread defunct</span><span style="color: #cccccc; font-style: italic;">*/</span>
    rt_list_init(&amp;rt_thread_defunct);
}
</pre>




<p>
这里面比较主要的一个调用是 <code>rt_list_init()</code> 函数
</p>
<p>
跟踪一下代码
</p>
<p>
rtservice.h
</p>


<pre class="src src-c">
rt_inline <span style="color: #9acd32; font-weight: bold;">void</span> <span style="color: #ffff00; font-weight: bold; font-style: italic;">rt_list_init</span>(<span style="color: #9acd32; font-weight: bold;">rt_list_t</span> *<span style="color: #add8e6; font-weight: bold; font-style: italic;">l</span>)
{
    l-&gt;next = l-&gt;prev = l;
}
<span style="color: #cccccc; font-style: italic;">/*</span><span style="color: #cccccc; font-style: italic;">&#19968;&#20010;&#25351;&#21521;&#33258;&#24049;&#30340;&#38142;&#34920;&#65292;&#36824;&#26159;&#21452;&#21521;&#38142;&#34920;</span><span style="color: #cccccc; font-style: italic;">*/</span>
</pre>




<pre class="src src-c">
<span style="color: #add8e6; font-weight: bold;">struct</span> <span style="color: #9acd32; font-weight: bold;">rt_list_node</span>
{
    <span style="color: #add8e6; font-weight: bold;">struct</span> <span style="color: #9acd32; font-weight: bold;">rt_list_node</span> *<span style="color: #add8e6; font-weight: bold; font-style: italic;">next</span>;
    <span style="color: #add8e6; font-weight: bold;">struct</span> <span style="color: #9acd32; font-weight: bold;">rt_lsit_node</span> *<span style="color: #add8e6; font-weight: bold; font-style: italic;">prev</span>;
};
<span style="color: #add8e6; font-weight: bold;">typedef</span> <span style="color: #add8e6; font-weight: bold;">struct</span> <span style="color: #9acd32; font-weight: bold;">rt_list_node</span> <span style="color: #9acd32; font-weight: bold;">rt_list_t</span>;
<span style="color: #cccccc; font-style: italic;">/*</span><span style="color: #cccccc; font-style: italic;">&#23450;&#20041;&#20102;&#19968;&#20010;&#38142;&#34920;&#20013;&#30340;&#19968;&#20010;&#33410;&#28857;</span><span style="color: #cccccc; font-style: italic;">*/</span>
</pre>




<p>
目前，我们接触到了一个数据结构，就是双向链表，而且是跟调度相关的。
</p>
<p>
暂时能想到的关联就是用这个双向链表管理所有的进程。
</p>
</div>

</div>

<div id="outline-container-2.7" class="outline-4">
<h4 id="sec-2.7">2.7 <code>rt_device_init_all()</code> <code>rt_application_init()</code> </h4>
<div id="text-2.7">

<p><code>rt_device_init_all()</code> 和 <code>rt_application_init()</code> 暂时先不分析。
</p>
<p>
device里面出现了object，而且是个抽象的设备层，这个放到后面再研究。
</p>
<p>
application则是创建线程，也先不管。
</p>
</div>

</div>

<div id="outline-container-2.8" class="outline-4">
<h4 id="sec-2.8">2.8 <code>rt_system_timer_thread_init()</code> </h4>
<div id="text-2.8">

<p>这个函数将会初始化所有的系统定时器线程
</p>


<pre class="src src-c">
<span style="color: #9acd32; font-weight: bold;">void</span> <span style="color: #ffff00; font-weight: bold; font-style: italic;">rt_system_timer_thread_init</span>(<span style="color: #9acd32; font-weight: bold;">void</span>)
{
<span style="color: #0000cd;">#ifdef</span> RT_USING_TIMER_SOFT
    rt_list_init(&amp;rt_soft_timer_list);

    <span style="color: #cccccc; font-style: italic;">/*</span><span style="color: #cccccc; font-style: italic;">start software timer thread</span><span style="color: #cccccc; font-style: italic;">*/</span>
    rt_thread_init(&amp;timer_thread,
             <span style="color: #8fbc8f; font-style: italic;">"timer"</span>,
             rt_thread_timer_entry, RT_NULL,
             &amp;timer_thread_stack =[0]=, <span style="color: #add8e6; font-weight: bold;">sizeof</span>(timer_thread_stack),
             RT_TIMER_THREAD_PRIO, 10);

    <span style="color: #cccccc; font-style: italic;">/*</span><span style="color: #cccccc; font-style: italic;">startup</span><span style="color: #cccccc; font-style: italic;">*/</span>
    rt_thread_startup(&amp;timer_thread);
<span style="color: #0000cd;">#endif</span>
}
<span style="color: #0000cd;">#END_SRC</span>

&#23450;&#20041;&#20102;&#19968;&#20010;&#36719;&#23450;&#26102;&#22120;&#21452;&#21521;&#38142;&#34920; =rt_soft_timer_list=

&#21448;&#24320;&#20102;&#19968;&#20010;&#32447;&#31243; =rt_thread_timer_entry=

=rt_thread_startup= &#26159;&#29992;&#26469;&#21551;&#21160;&#19968;&#20010;&#32447;&#31243;&#65292;&#24182;&#19988;&#25226;&#23427;&#25918;&#21040;&#31995;&#32479;ready queue&#37324;&#38754;&#21435;&#12290;

&#23545;&#20110; =rt_thread_init= &#35299;&#37322;&#26159;&#36825;&#20010;&#20989;&#25968;&#29992;&#26469;&#21021;&#22987;&#21270;&#19968;&#20010;&#32447;&#31243;&#65292;&#36890;&#24120;&#23427;&#34987;&#29992;&#26469;&#21021;&#22987;&#21270;&#19968;&#20010;&#38745;&#24577;thread object&#12290;

&#24182;&#19988;&#35843;&#29992;&#20102; =rt_object_init= &#21644; =_rt_thread_init= &#20004;&#20010;&#20989;&#25968;

&#25105;&#23545;object&#26242;&#26102;&#36824;&#19981;&#24819;&#30896;&#65292;&#20808;&#28145;&#31350;&#20197;&#19979; =_rt_thread_init= &#20989;&#25968;

#+BEGIN_SRC c
<span style="color: #add8e6; font-weight: bold;">static</span> rt_err_t _rt_thread_init(<span style="color: #add8e6; font-weight: bold;">struct</span> <span style="color: #9acd32; font-weight: bold;">rt_thread</span> *<span style="color: #add8e6; font-weight: bold; font-style: italic;">thread</span>,
                                <span style="color: #add8e6; font-weight: bold;">const</span> <span style="color: #9acd32; font-weight: bold;">char</span> *<span style="color: #add8e6; font-weight: bold; font-style: italic;">name</span>,
                                <span style="color: #9acd32; font-weight: bold;">void</span> (*<span style="color: #add8e6; font-weight: bold; font-style: italic;">entry</span>)(<span style="color: #9acd32; font-weight: bold;">void</span> *<span style="color: #add8e6; font-weight: bold; font-style: italic;">parameter</span>),
                                <span style="color: #9acd32; font-weight: bold;">void</span> *<span style="color: #add8e6; font-weight: bold; font-style: italic;">parameter</span>,
                                <span style="color: #9acd32; font-weight: bold;">void</span> *<span style="color: #add8e6; font-weight: bold; font-style: italic;">stack_start</span>,
                                <span style="color: #9acd32; font-weight: bold;">rt_uint32_t</span> <span style="color: #add8e6; font-weight: bold; font-style: italic;">stack_size</span>,
                                <span style="color: #9acd32; font-weight: bold;">rt_uint8_t</span> <span style="color: #add8e6; font-weight: bold; font-style: italic;">priority</span>, 
                                <span style="color: #9acd32; font-weight: bold;">rt_uint32_t</span> <span style="color: #add8e6; font-weight: bold; font-style: italic;">tick</span>)
{
    <span style="color: #cccccc; font-style: italic;">/*</span><span style="color: #cccccc; font-style: italic;">init thread list</span><span style="color: #cccccc; font-style: italic;">*/</span>
    rt_list_init(&amp;(thread-&gt;tlist));

    thread-&gt;entry = (<span style="color: #9acd32; font-weight: bold;">void</span>*)entry;
    thread-&gt;parameter = parameter;

    <span style="color: #cccccc; font-style: italic;">/*</span><span style="color: #cccccc; font-style: italic;">stack init</span><span style="color: #cccccc; font-style: italic;">*/</span>
    thread-&gt;stack_addr = stack_start;
    thread-&gt;stack_size = stack_size;

    <span style="color: #cccccc; font-style: italic;">/*</span><span style="color: #cccccc; font-style: italic;">init thread stack</span><span style="color: #cccccc; font-style: italic;">*/</span>
    rt_memset(thread-&gt;stack_addr, <span style="color: #8fbc8f; font-style: italic;">'#'</span>, thread-&gt;stack_size);
    thread-&gt;sp = (<span style="color: #9acd32; font-weight: bold;">void</span>*)rt_hw_stack_init(thread-&gt;entry, thread-&gt;parameter,
                                          (<span style="color: #9acd32; font-weight: bold;">void</span>*)((<span style="color: #9acd32; font-weight: bold;">char</span>*)thread-&gt;stack_addr
                                         +thread-&gt;stack_size - 4),
                                         (<span style="color: #9acd32; font-weight: bold;">void</span>*)rt_thread_exit);

    <span style="color: #cccccc; font-style: italic;">/*</span><span style="color: #cccccc; font-style: italic;">priority init</span><span style="color: #cccccc; font-style: italic;">*/</span>
    RT_ASSERT(priority &lt; RT_THREAD_PRIORITY_MAX);
    thread-&gt;init_priority = priority;
    thread-&gt;current_priority = priority;

    <span style="color: #cccccc; font-style: italic;">/* </span><span style="color: #cccccc; font-style: italic;">tick init </span><span style="color: #cccccc; font-style: italic;">*/</span>
    thread-&gt;init_ick = tick;
    thread-&gt;remaining_tick = tick;

    <span style="color: #cccccc; font-style: italic;">/*</span><span style="color: #cccccc; font-style: italic;">error and flags</span><span style="color: #cccccc; font-style: italic;">*/</span>
    thread-&gt;error = RT_EOK;
    thread-&gt;stat = RT_THREAD_INIT;

    <span style="color: #cccccc; font-style: italic;">/*</span><span style="color: #cccccc; font-style: italic;">initialize cleanup function and user data</span><span style="color: #cccccc; font-style: italic;">*/</span>
    thread-&gt;cleanup = 0;
    thread-&gt;user_data = 0;

    <span style="color: #cccccc; font-style: italic;">/*</span><span style="color: #cccccc; font-style: italic;">init thread timer</span><span style="color: #cccccc; font-style: italic;">*/</span>
    rt_timer_init(&amp;(thread-&gt;thread_tiemr),
                  thread-&gt;name,
                  rt_thread_timeout,
                  thread,
                  0,
                  RT_TIMER_FLAG_ONE_SHOT);

    <span style="color: #add8e6; font-weight: bold;">return</span> RT_EOK;
}
</pre>



<p>
这里面，初始化了一个双向链表，填充了thread结构体，初始化了一个定时器。
</p>
<p>
下面可以看一下thread结构体
</p>


<pre class="src src-c">
<span style="color: #add8e6; font-weight: bold;">struct</span> <span style="color: #9acd32; font-weight: bold;">rt_thread</span>
{
    <span style="color: #cccccc; font-style: italic;">/*</span><span style="color: #cccccc; font-style: italic;">rt object</span><span style="color: #cccccc; font-style: italic;">*/</span>
    <span style="color: #9acd32; font-weight: bold;">char</span> <span style="color: #add8e6; font-weight: bold; font-style: italic;">name</span>[RT_NAME_MAX]; <span style="color: #cccccc; font-style: italic;">/* </span><span style="color: #cccccc; font-style: italic;">&#32447;&#31243;&#30340;&#21517;&#23383; </span><span style="color: #cccccc; font-style: italic;">*/</span>
    <span style="color: #9acd32; font-weight: bold;">rt_uint8_t</span> <span style="color: #add8e6; font-weight: bold; font-style: italic;">type</span>;        <span style="color: #cccccc; font-style: italic;">/* </span><span style="color: #cccccc; font-style: italic;">&#23545;&#35937;&#30340;&#31867;&#22411; </span><span style="color: #cccccc; font-style: italic;">*/</span>
    <span style="color: #9acd32; font-weight: bold;">rt_uint8_t</span> <span style="color: #add8e6; font-weight: bold; font-style: italic;">flags</span>;       <span style="color: #cccccc; font-style: italic;">/* </span><span style="color: #cccccc; font-style: italic;">&#32447;&#31243;&#30340;&#26631;&#24535; </span><span style="color: #cccccc; font-style: italic;">*/</span>

<span style="color: #0000cd;">#ifdef</span> RT_USING_MODULE
    <span style="color: #9acd32; font-weight: bold;">void</span> *<span style="color: #add8e6; font-weight: bold; font-style: italic;">module_id</span>;        <span style="color: #cccccc; font-style: italic;">/* </span><span style="color: #cccccc; font-style: italic;">&#24212;&#29992;&#27169;&#22359;&#30340;id </span><span style="color: #cccccc; font-style: italic;">*/</span>
<span style="color: #0000cd;">#endif</span>

    <span style="color: #9acd32; font-weight: bold;">rt_list_t</span> <span style="color: #add8e6; font-weight: bold; font-style: italic;">list</span>;         <span style="color: #cccccc; font-style: italic;">/* </span><span style="color: #cccccc; font-style: italic;">&#23545;&#35937;&#21015;&#34920; </span><span style="color: #cccccc; font-style: italic;">*/</span>
    <span style="color: #9acd32; font-weight: bold;">rt_list_t</span> <span style="color: #add8e6; font-weight: bold; font-style: italic;">tlist</span>;        <span style="color: #cccccc; font-style: italic;">/* </span><span style="color: #cccccc; font-style: italic;">&#32447;&#31243;&#21015;&#34920; </span><span style="color: #cccccc; font-style: italic;">*/</span>

    <span style="color: #cccccc; font-style: italic;">/* </span><span style="color: #cccccc; font-style: italic;">&#26632;&#25351;&#38024;&#21644;&#20837;&#21475; </span><span style="color: #cccccc; font-style: italic;">*/</span>
    <span style="color: #9acd32; font-weight: bold;">void</span>    *<span style="color: #add8e6; font-weight: bold; font-style: italic;">sp</span>;            <span style="color: #cccccc; font-style: italic;">/*</span><span style="color: #cccccc; font-style: italic;">&#26632;&#25351;&#38024;</span><span style="color: #cccccc; font-style: italic;">*/</span>
    <span style="color: #9acd32; font-weight: bold;">void</span>    *<span style="color: #add8e6; font-weight: bold; font-style: italic;">entry</span>;         <span style="color: #cccccc; font-style: italic;">/*</span><span style="color: #cccccc; font-style: italic;">&#20837;&#21475;</span><span style="color: #cccccc; font-style: italic;">*/</span>
    <span style="color: #9acd32; font-weight: bold;">void</span>    *<span style="color: #add8e6; font-weight: bold; font-style: italic;">parameter</span>;     <span style="color: #cccccc; font-style: italic;">/*</span><span style="color: #cccccc; font-style: italic;">&#21442;&#25968;</span><span style="color: #cccccc; font-style: italic;">*/</span>
    <span style="color: #9acd32; font-weight: bold;">void</span>    *<span style="color: #add8e6; font-weight: bold; font-style: italic;">stack_addr</span>;    <span style="color: #cccccc; font-style: italic;">/*</span><span style="color: #cccccc; font-style: italic;">&#26632;&#22320;&#22336;</span><span style="color: #cccccc; font-style: italic;">*/</span>
    <span style="color: #9acd32; font-weight: bold;">rt_uint16_t</span> <span style="color: #add8e6; font-weight: bold; font-style: italic;">stack_size</span>; <span style="color: #cccccc; font-style: italic;">/*</span><span style="color: #cccccc; font-style: italic;">&#26632;&#22823;&#23567;</span><span style="color: #cccccc; font-style: italic;">*/</span>

    <span style="color: #cccccc; font-style: italic;">/*</span><span style="color: #cccccc; font-style: italic;">error code</span><span style="color: #cccccc; font-style: italic;">*/</span>
    <span style="color: #9acd32; font-weight: bold;">rt_err_t</span> <span style="color: #add8e6; font-weight: bold; font-style: italic;">error</span>;         <span style="color: #cccccc; font-style: italic;">/*</span><span style="color: #cccccc; font-style: italic;">&#38169;&#35823;&#30721;</span><span style="color: #cccccc; font-style: italic;">*/</span>

    <span style="color: #9acd32; font-weight: bold;">rt_uint8_t</span> <span style="color: #add8e6; font-weight: bold; font-style: italic;">stat</span>;        <span style="color: #cccccc; font-style: italic;">/*</span><span style="color: #cccccc; font-style: italic;">&#32447;&#31243;&#29366;&#24577;</span><span style="color: #cccccc; font-style: italic;">*/</span>

    <span style="color: #cccccc; font-style: italic;">/*</span><span style="color: #cccccc; font-style: italic;">&#23646;&#24615;</span><span style="color: #cccccc; font-style: italic;">*/</span>
    <span style="color: #9acd32; font-weight: bold;">rt_uint8_t</span> <span style="color: #add8e6; font-weight: bold; font-style: italic;">current_priority</span>;    <span style="color: #cccccc; font-style: italic;">/*</span><span style="color: #cccccc; font-style: italic;">&#24403;&#21069;&#20248;&#20808;&#32423;</span><span style="color: #cccccc; font-style: italic;">*/</span>
    <span style="color: #9acd32; font-weight: bold;">rt_uint8_t</span> <span style="color: #add8e6; font-weight: bold; font-style: italic;">init_priority</span>;       <span style="color: #cccccc; font-style: italic;">/*</span><span style="color: #cccccc; font-style: italic;">&#21021;&#22987;&#21270;&#20248;&#20808;&#32423;</span><span style="color: #cccccc; font-style: italic;">*/</span>
<span style="color: #0000cd;">#if</span> RT_THREAD_PRIORITY_MAX &gt; 32
    <span style="color: #9acd32; font-weight: bold;">rt_uint8_t</span> <span style="color: #add8e6; font-weight: bold; font-style: italic;">number</span>;
    <span style="color: #9acd32; font-weight: bold;">rt_uint8_t</span> <span style="color: #add8e6; font-weight: bold; font-style: italic;">high_mask</span>;
<span style="color: #0000cd;">#endif</span>
    <span style="color: #9acd32; font-weight: bold;">rt_uint32_t</span> <span style="color: #add8e6; font-weight: bold; font-style: italic;">number_mask</span>;

<span style="color: #0000cd;">#if</span> <span style="color: #0000cd;">defined</span>(RT_USING_EVENT)
    <span style="color: #cccccc; font-style: italic;">/*</span><span style="color: #cccccc; font-style: italic;">thread event</span><span style="color: #cccccc; font-style: italic;">*/</span>
    <span style="color: #9acd32; font-weight: bold;">rt_uint32_t</span> <span style="color: #add8e6; font-weight: bold; font-style: italic;">event_set</span>;
    <span style="color: #9acd32; font-weight: bold;">rt_uint8_t</span>  <span style="color: #add8e6; font-weight: bold; font-style: italic;">event_info</span>;
<span style="color: #0000cd;">#endif</span>

    <span style="color: #9acd32; font-weight: bold;">rt_ubase_t</span> <span style="color: #add8e6; font-weight: bold; font-style: italic;">init_tick</span>;  <span style="color: #cccccc; font-style: italic;">/*</span><span style="color: #cccccc; font-style: italic;">&#32447;&#31243;&#30340;&#21021;&#22987;&#21270;&#30340;tick</span><span style="color: #cccccc; font-style: italic;">*/</span>
    <span style="color: #9acd32; font-weight: bold;">rt_ubase_t</span> <span style="color: #add8e6; font-weight: bold; font-style: italic;">remaining_tick</span>; <span style="color: #cccccc; font-style: italic;">/*</span><span style="color: #cccccc; font-style: italic;">&#21097;&#19979;&#30340;tick</span><span style="color: #cccccc; font-style: italic;">*/</span>

    <span style="color: #add8e6; font-weight: bold;">struct</span> <span style="color: #9acd32; font-weight: bold;">rt_timer</span> <span style="color: #add8e6; font-weight: bold; font-style: italic;">thread_timer</span>; <span style="color: #cccccc; font-style: italic;">/*</span><span style="color: #cccccc; font-style: italic;">&#20869;&#24314;&#32447;&#31243;&#23450;&#26102;&#22120;</span><span style="color: #cccccc; font-style: italic;">*/</span>

    <span style="color: #9acd32; font-weight: bold;">void</span> (*<span style="color: #ffff00; font-weight: bold; font-style: italic;">cleanup</span>)(<span style="color: #add8e6; font-weight: bold;">struct</span> <span style="color: #9acd32; font-weight: bold;">rt_thread</span> *<span style="color: #add8e6; font-weight: bold; font-style: italic;">tid</span>); <span style="color: #cccccc; font-style: italic;">/* </span><span style="color: #cccccc; font-style: italic;">&#24403;&#32447;&#31243;&#36864;&#20986;&#30340;&#26102;&#20505;&#30340;&#28165;&#29702;&#20989;&#25968; </span><span style="color: #cccccc; font-style: italic;">*/</span>

    <span style="color: #9acd32; font-weight: bold;">rt_uint32_t</span> <span style="color: #add8e6; font-weight: bold; font-style: italic;">user_data</span>; <span style="color: #cccccc; font-style: italic;">/* </span><span style="color: #cccccc; font-style: italic;">&#36825;&#20010;&#32447;&#31243;&#30340;&#31169;&#26377;&#29992;&#25143;&#25968;&#25454; </span><span style="color: #cccccc; font-style: italic;">*/</span>
};
<span style="color: #add8e6; font-weight: bold;">typedef</span> <span style="color: #add8e6; font-weight: bold;">struct</span> <span style="color: #9acd32; font-weight: bold;">rt_thread</span> *<span style="color: #9acd32; font-weight: bold;">rt_thread_t</span>;
</pre>




</div>

</div>

<div id="outline-container-2.9" class="outline-4">
<h4 id="sec-2.9">2.9 <code>rt_thread_idle_init()</code> </h4>
<div id="text-2.9">

<p>初始化空闲线程
</p>
<p>
启动线程 <code>rt_thread_idle_entry</code>,然后执行了 <code>rt_thread_idle_excute()</code> 函数
</p>
</div>

</div>

<div id="outline-container-2.10" class="outline-4">
<h4 id="sec-2.10">2.10 <code>rt_system_scheduler_start()</code> </h4>
<div id="text-2.10">

<p>开始调度
</p>
<p>
scheduler.c
</p>
<p>
这个函数将开始执行调度，它将会选择一个具有最高优先级的线程，然后交换到该线程
</p>


<pre class="src src-c">
<span style="color: #9acd32; font-weight: bold;">void</span> <span style="color: #ffff00; font-weight: bold; font-style: italic;">rt_system_scheduler_start</span>(<span style="color: #9acd32; font-weight: bold;">void</span>)
{
    <span style="color: #add8e6; font-weight: bold;">register</span> <span style="color: #add8e6; font-weight: bold;">struct</span> <span style="color: #9acd32; font-weight: bold;">rt_thread</span> *<span style="color: #add8e6; font-weight: bold; font-style: italic;">to_thread</span>;
    <span style="color: #add8e6; font-weight: bold;">register</span> <span style="color: #9acd32; font-weight: bold;">rt_ubase_t</span> <span style="color: #add8e6; font-weight: bold; font-style: italic;">highest_ready_priority</span>;
    
<span style="color: #0000cd;">#if</span> RT_THREAD_PRIORITY_MAX == 8
    highest_ready_priority = rt_lowest_bitmap[rt_thread_ready_priority_group];
<span style="color: #0000cd;">#endif</span>
    <span style="color: #add8e6; font-weight: bold;">register</span> <span style="color: #9acd32; font-weight: bold;">rt_ubase_t</span> <span style="color: #add8e6; font-weight: bold; font-style: italic;">number</span>;
    <span style="color: #cccccc; font-style: italic;">/*</span><span style="color: #cccccc; font-style: italic;">find out the highest priority task</span><span style="color: #cccccc; font-style: italic;">*/</span>
    <span style="color: #add8e6; font-weight: bold;">if</span> (rt_thread_ready_priority_group &amp; 0xff) {
        number = rt_lowest_bitmap[rt_thread_ready_priority_group &amp; 0xff];
    } <span style="color: #add8e6; font-weight: bold;">else</span> <span style="color: #add8e6; font-weight: bold;">if</span> (rt_thread_ready_priority_group &amp; 0xff00) {
        number = rt_lowest_bitmap[(rt_thread_ready_priority_group &gt;&gt; 8) &amp; 0xff + 8;
    } <span style="color: #add8e6; font-weight: bold;">else</span> <span style="color: #add8e6; font-weight: bold;">if</span> (rt_thread_ready_priority_group &amp; 0xff0000) {
       number = rt_lowest_bitmap[(rt_thread_ready_priority_group &gt;&gt; 16) &amp; 0xff]+ 16;
    } <span style="color: #add8e6; font-weight: bold;">else</span> {
       number = rt_lowest_bitmap[(rt_thread_ready_priority_group &gt;&gt; 24) &amp; 0xff] + 24;
    }

<span style="color: #0000cd;">#if</span> RT_THREAD_PRIORITY_MAX &gt; 32
    highest_ready_priority = (number &lt;&lt; 3) + rt_lowest_bitmap[rt_thread_ready_table[number]];
<span style="color: #0000cd;">#else</span>
    highest_ready_priority = number;
<span style="color: #0000cd;">#endif</span>
<span style="color: #0000cd;">#endif</span>
    
    <span style="color: #cccccc; font-style: italic;">/* </span><span style="color: #cccccc; font-style: italic;">get switch to thread </span><span style="color: #cccccc; font-style: italic;">*/</span>
    to_thread = rt_list_entry(rt_thread_priority_table[highest_ready_priority].next,
                              <span style="color: #add8e6; font-weight: bold;">struct</span> <span style="color: #9acd32; font-weight: bold;">rt_thread</span>, tlist);

    rt_current_thread = to_thread;

    <span style="color: #cccccc; font-style: italic;">/* </span><span style="color: #cccccc; font-style: italic;">switch to new thread </span><span style="color: #cccccc; font-style: italic;">*/</span>
    rt_hw_context_switch_to((<span style="color: #9acd32; font-weight: bold;">rt_uint32_t</span>)&amp;to_thread-&gt;sp);

    <span style="color: #cccccc; font-style: italic;">/* </span><span style="color: #cccccc; font-style: italic;">never come back </span><span style="color: #cccccc; font-style: italic;">*/</span>
}
</pre>




<p>
<code>rt_list_entry</code> 做的事情是通过地址偏移量计算出来某个结构体的首地址
</p>
<p>
<code>rt_hw_context_switch_to</code> 是个汇编的过程 <code>context_xxx.S</code> 里面
</p>
<p>
r0用来存放to参数，这个函数用来处理第一个线程交换。没太看懂这个汇编过程的主要用意，主要还是对线程的上下文交换需要作哪些事情不是很清楚。
</p>
<p>
那么在此时，优先级别最高的线程是哪个呢？这是个问题！
</p>

<hr/>
</div>
</div>

</div>

<div id="outline-container-3" class="outline-2">
<h2 id="sec-3">3 优先级探索 </h2>
<div id="text-3">


<p>
根据 <code>void rt_system_scheduler_start(void)</code> 函数中的内容，我们可以看到，跟优先级有关系的有下面这么几个变量
</p>
<ul>
<li>
<code>register rt_ubase_t highest_ready_priority</code>
</li>
<li>
<code>register rt_ubase_t number</code>
</li>
<li>
<code>rt_thread_ready_priority_group</code>

</li>
</ul>

<p>打印一下信息可以得到
</p>


<pre class="src src-sh">
<span style="color: #add8e6; font-weight: bold; font-style: italic;">rt_thread_ready_priority_group</span>=80000400
<span style="color: #add8e6; font-weight: bold; font-style: italic;">number</span>=a
<span style="color: #add8e6; font-weight: bold; font-style: italic;">highest_ready_priority</span>=a
</pre>



<p>
因此，我们要研究一下，它们是怎么被赋值的。
</p>
<p>
先关注一下 <code>rt_thread_ready_priority_group</code> 这个变量，它在 <code>rt_system_scheduler_init</code> 函数里面已经被初始化为0了。
</p>
<p>
在这之间，还有三个函数需要查看 <code>rt_application_init()</code>, <code>rt_system_timer_thread_init()</code>, <code>rt_thread_idle_init()</code>, 这三个里面都建立了线程。
</p>



<pre class="src src-c">
rt_thread_create(<span style="color: #8fbc8f; font-style: italic;">"init"</span>,                        <span style="color: #cccccc; font-style: italic;">//</span><span style="color: #cccccc; font-style: italic;">&#32447;&#31243;&#30340;&#21517;&#23383;
</span>                  rt_init_thread_entry,         <span style="color: #cccccc; font-style: italic;">//</span><span style="color: #cccccc; font-style: italic;">&#32447;&#31243;&#30340;&#20837;&#21475;&#20989;&#25968;
</span>                  RT_NULL,                      <span style="color: #cccccc; font-style: italic;">//</span><span style="color: #cccccc; font-style: italic;">&#20837;&#21475;&#20989;&#25968;&#30340;&#21442;&#25968;
</span>                  2048,                         <span style="color: #cccccc; font-style: italic;">//</span><span style="color: #cccccc; font-style: italic;">&#32447;&#31243;&#26632;&#30340;&#22823;&#23567;
</span>                  RT_THREAD_PRIORITY_MAX/3,     <span style="color: #cccccc; font-style: italic;">//</span><span style="color: #cccccc; font-style: italic;">&#32447;&#31243;&#30340;&#20248;&#20808;&#32423;
</span>                  20);                          <span style="color: #cccccc; font-style: italic;">//</span><span style="color: #cccccc; font-style: italic;">&#21516;&#26679;&#20248;&#20808;&#32423;&#24773;&#20917;&#19979;&#30340;&#20998;&#37197;&#30340;&#26102;&#38388;&#29255;
</span></pre>





<pre class="src src-c">
rt_thread_init(&amp;timer_thread,                   <span style="color: #cccccc; font-style: italic;">//</span><span style="color: #cccccc; font-style: italic;">&#38745;&#24577;&#32447;&#31243;&#23545;&#35937;
</span>               <span style="color: #8fbc8f; font-style: italic;">"tiemr"</span>,                         <span style="color: #cccccc; font-style: italic;">//</span><span style="color: #cccccc; font-style: italic;">&#32447;&#31243;&#21517;&#23383;
</span>               rt_thread_timer_entry,           <span style="color: #cccccc; font-style: italic;">//</span><span style="color: #cccccc; font-style: italic;">&#32447;&#31243;&#20989;&#25968;&#20837;&#21475;
</span>               RT_NULL,                         <span style="color: #cccccc; font-style: italic;">//</span><span style="color: #cccccc; font-style: italic;">&#32447;&#31243;&#20989;&#25968;&#21442;&#25968;
</span>               &amp;timer_thread_stack[0],          <span style="color: #cccccc; font-style: italic;">//</span><span style="color: #cccccc; font-style: italic;">&#32447;&#31243;&#26632;&#24320;&#22987;&#22320;&#22336;
</span>               <span style="color: #add8e6; font-weight: bold;">sizeof</span>(timer_thread_stack),      <span style="color: #cccccc; font-style: italic;">//</span><span style="color: #cccccc; font-style: italic;">&#32447;&#31243;&#26632;&#22823;&#23567;
</span>               RT_TIMER_THREAD_PRIO,            <span style="color: #cccccc; font-style: italic;">//</span><span style="color: #cccccc; font-style: italic;">&#32447;&#31243;&#20248;&#20808;&#32423;
</span>               10)                              <span style="color: #cccccc; font-style: italic;">//</span><span style="color: #cccccc; font-style: italic;">&#26102;&#38388;&#29255;
</span></pre>





<pre class="src src-c">
rt_thread_init(&amp;idle,
               <span style="color: #8fbc8f; font-style: italic;">"tidle"</span>,
               rt_thread_idle_entry,
               RT_NULL,
               &amp;rt_thread_stack[0],
               <span style="color: #add8e6; font-weight: bold;">sizeof</span>(rt_thread_stack),
               RT_THREAD_PRIORITY_MAX-1,
               32);
</pre>




<p>
那么我们打印一下init和create的线程信息，看一下优先级是怎样的
</p>



<pre class="src src-sh">
[create]thread name:init priority:a
[init]thread name:tidle priority:1f
[init]thread name:tshell priority:14
[init]thread name:erx priority:e
[init]thread name:etx priority:e
[create]thread name:tcpip priority:c
[create]thread name:rtgui priority:f
[create]thread name:touch priority:e
[init]thread name:mmcsd_detect priority:f
[create]thread name:key priority:e
[create]thread name:app_mgr priority:14
[create]thread name:cali priority:14
</pre>




<p>
而且是，在 <code>rt_system_scheduler_start()</code> 的时候，只有init和tidle两个线程被注册了。
</p>
<p>
还有一个timer的线程不知道为什么没有打印出来，也是通过 <code>rt_thread_init</code> 注册的。
</p>
<p>
现在，先看一下这三个线程所注册的函数
</p>
<p>
init-&gt; <code>rt_init_thread_entry</code>
</p>
<p>
timer-&gt; <code>rt_thread_timer_entry</code>
</p>
<p>
tidle-&gt; <code>rt_thread_idle_entry</code>
</p>
<p>
<code>rt_init_thread_entry</code> 是最麻烦的，先来看一下它
</p>


<pre class="src src-c">
<span style="color: #9acd32; font-weight: bold;">void</span> <span style="color: #ffff00; font-weight: bold; font-style: italic;">rt_init_thread_entry</span>(<span style="color: #9acd32; font-weight: bold;">void</span> *<span style="color: #add8e6; font-weight: bold; font-style: italic;">parameter</span>)
{
<span style="color: #0000cd;">#ifdef</span> RT_USING_COMPONENTS_INIT
    <span style="color: #cccccc; font-style: italic;">/* </span><span style="color: #cccccc; font-style: italic;">initialization RT-Thread Components </span><span style="color: #cccccc; font-style: italic;">*/</span>
    rt_components_init();
<span style="color: #0000cd;">#endif</span>
    rt_platform_init();
    <span style="color: #cccccc; font-style: italic;">/* </span><span style="color: #cccccc; font-style: italic;">Filesystem Initialization </span><span style="color: #cccccc; font-style: italic;">*/</span>
<span style="color: #0000cd;">#ifdef</span> RT_USING_DFS
    <span style="color: #cccccc; font-style: italic;">/*</span><span style="color: #cccccc; font-style: italic;">mount sd card fat partition 1 as root directory </span><span style="color: #cccccc; font-style: italic;">*/</span>
    <span style="color: #add8e6; font-weight: bold;">if</span> (dfs_mount(<span style="color: #8fbc8f; font-style: italic;">"sd0"</span>, <span style="color: #8fbc8f; font-style: italic;">"/"</span>, <span style="color: #8fbc8f; font-style: italic;">"elm"</span>, 0, 0)== 0) {
        rt_kprintf(<span style="color: #8fbc8f; font-style: italic;">"File System initialized!\n"</span>);
    } <span style="color: #add8e6; font-weight: bold;">else</span>  {
        rt_kprintf(<span style="color: #8fbc8f; font-style: italic;">"File System initialzation failed!\n"</span>);
    }
<span style="color: #0000cd;">#endif</span>
<span style="color: #0000cd;">#ifdef</span> RT_USING_RTGUI
    realtouch_ui_init();
<span style="color: #0000cd;">#endif</span>
}
</pre>



<p>
调用了三个函数做了不少事情。
</p>
<p>
看一下 <code>rt_thread_timer_entry</code>
</p>


<pre class="src src-c">
<span style="color: #add8e6; font-weight: bold;">static</span> <span style="color: #9acd32; font-weight: bold;">void</span> <span style="color: #ffff00; font-weight: bold; font-style: italic;">rt_thread_timer_entry</span>(<span style="color: #9acd32; font-weight: bold;">void</span> *<span style="color: #add8e6; font-weight: bold; font-style: italic;">parameter</span>)
{
    <span style="color: #9acd32; font-weight: bold;">rt_tick_t</span> <span style="color: #add8e6; font-weight: bold; font-style: italic;">next_timeout</span>;

    <span style="color: #add8e6; font-weight: bold;">while</span> (1) {
        next_timeout = rt_timer_list_next_timeout(&amp;rt_soft_timer_list);
        <span style="color: #add8e6; font-weight: bold;">if</span> (next_timeout == RT_TICK_MAX) {
            rt_thread_suspend(rt_thread_self());
            rt_schedule();
        } <span style="color: #add8e6; font-weight: bold;">else</span> {
            rt_thread_delay(next_timeout);
        }

        <span style="color: #cccccc; font-style: italic;">/*</span><span style="color: #cccccc; font-style: italic;">lock scheduler</span><span style="color: #cccccc; font-style: italic;">*/</span>
        rt_enter_critical();
        <span style="color: #cccccc; font-style: italic;">/*</span><span style="color: #cccccc; font-style: italic;">check software timer</span><span style="color: #cccccc; font-style: italic;">*/</span>
        rt_soft_timer_check();
        <span style="color: #cccccc; font-style: italic;">/*</span><span style="color: #cccccc; font-style: italic;">unlock scheduler</span><span style="color: #cccccc; font-style: italic;">*/</span>
        rt_exit_critical();
    }
}
</pre>




<p>
<code>rt_thread_idle_entry</code>
</p>


<pre class="src src-c">
<span style="color: #add8e6; font-weight: bold;">static</span> <span style="color: #9acd32; font-weight: bold;">void</span> <span style="color: #ffff00; font-weight: bold; font-style: italic;">rt_thread_idle_entry</span>(<span style="color: #9acd32; font-weight: bold;">void</span> *<span style="color: #add8e6; font-weight: bold; font-style: italic;">parameter</span>)
{
    <span style="color: #add8e6; font-weight: bold;">while</span> (1) {
<span style="color: #0000cd;">        #define</span> <span style="color: #add8e6; font-weight: bold; font-style: italic;">RT_USING_HOOK</span>
        <span style="color: #add8e6; font-weight: bold;">if</span> (rt_thread_idle_hook != RT_NULL) {
            rt_thread_idle_hook();
        }
<span style="color: #0000cd;">        #endif</span>
        rt_thread_idle_excute();
    }
}
</pre>




<p>
<code>rt_thread_idle_excute()</code> 函数是比较复杂的
</p>
<p>
这里面出现了两个while(1)的死循环。
</p>
<p>
timer主要做的事情是检查timeout，将超时的线程挂起，然后重新调度。
</p>
<p>
idle主要是把不需要的线程从链表里删除
</p>
<p>
这个具体执行调度的地方我还是不是很清楚，没有说找到特别明确的代码片段。
</p>

<hr/>

</div>

</div>

<div id="outline-container-4" class="outline-2">
<h2 id="sec-4">4 发现DEBUG </h2>
<div id="text-4">


<p>
rtdebug.h里面有好多的宏开关，我们应该尝试打开一下，看一下输出信息。
</p>



<pre class="src src-sh">
 <span style="color: #8fbc8f; font-style: italic;">\ </span>| /
- RT -     Thread Operating System
 / | <span style="color: #8fbc8f; font-style: italic;">\ </span>    1.1.0 build Sep  6 2012
 2006 - 2012 Copyright by rt-thread team
mem init, heap begin address 0x60000000, size 524264
start scheduler: max priority 0x20
malloc size 136
thread (NULL) take sem:heap, which value is: 1
thread (NULL) releases sem:heap, which value is: 0
allocate memory at 0x6000000c, size: 148
malloc size 2048
thread (NULL) take sem:heap, which value is: 1
thread (NULL) releases sem:heap, which value is: 0
allocate memory at 0x600000a0, size: 2060
[create]thread name:init priority:a
startup a thread:init with priority:10
thread resume:  init
insert thread[init], the priority: 10
[init]thread name:tidle priority:1f
startup a thread:tidle with priority:31
thread resume:  tidle
insert thread[tidle], the priority: 31
<span style="color: #add8e6; font-weight: bold; font-style: italic;">rt_thread_ready_priority_group</span>=80000400
<span style="color: #add8e6; font-weight: bold; font-style: italic;">number</span>=a
<span style="color: #add8e6; font-weight: bold; font-style: italic;">highest_ready_priority</span>=a
irq coming..., irq nest:0
timer check enter
timer check leave
irq leave, irq nest:1
irq coming..., irq nest:0
timer check enter
timer check leave
irq leave, irq nest:1
irq coming..., irq nest:0
timer check enter
timer check leave
irq leave, irq nest:1
irq coming..., irq nest:0
timer check enter
timer check leave
irq leave, irq nest:1
</pre>




<p>
debug全开之后的信息如上所示，以后的信息就更加混乱了，试图从上面的信息里面分析一些东西出来吧。
</p>
<p>
在scheduler.c中的每个函数入口和出口的地方都加入一个打印信息，得到了另外的一组调试数据。
</p>


<pre class="src src-sh">
 <span style="color: #8fbc8f; font-style: italic;">\ </span>| /
- RT -     Thread Operating System
 / | <span style="color: #8fbc8f; font-style: italic;">\ </span>    1.1.0 build Sep  6 2012
 2006 - 2012 Copyright by rt-thread team
[scheduler] enter rt_system_scheduler_init
start scheduler: max priority 0x20
[scheduler] leave rt_system_scheduler_init
[create]thread name:init priority:a
[scheduler] enter rt_schedule_insert_thread
insert thread[init], the priority: 10
[scheduler] leave rt_schedule_insert_thread
[init]thread name:tidle priority:1f
[scheduler] enter rt_schedule_insert_thread
insert thread[tidle], the priority: 31
[scheduler] leave rt_schedule_insert_thread
[scheduler] enter rt_system_scheduler_start
<span style="color: #add8e6; font-weight: bold; font-style: italic;">rt_thread_ready_priority_group</span>=80000400
<span style="color: #add8e6; font-weight: bold; font-style: italic;">number</span>=a
<span style="color: #add8e6; font-weight: bold; font-style: italic;">highest_ready_priority</span>=a
[scheduler] switch-to init
[init]thread name:tshell priority:14
[scheduler] enter rt_schedule_insert_thread
insert thread[tshell], the priority: 20
[scheduler] leave rt_schedule_insert_thread
[scheduler] enter rt_schedule
[scheduler] leave rt_schedule
[scheduler] enter rt_enter_critical
[scheduler] leave rt_enter_critical
[scheduler] enter rt_exit_critical
[scheduler] enter rt_schedule
[scheduler] leave rt_schedule
[scheduler] leave rt_exit_critical
[scheduler] enter rt_enter_critical
[scheduler] leave rt_enter_critical
[scheduler] enter rt_exit_critical
[scheduler] enter rt_schedule
[scheduler] leave rt_schedule
[scheduler] leave rt_exit_critical
[create]thread name:rtgui priority:f
[scheduler] enter rt_schedule_insert_thread
insert thread[rtgui], the priority: 15
[scheduler] leave rt_schedule_insert_thread
[scheduler] enter rt_schedule
[scheduler] leave rt_schedule
[scheduler] enter rt_enter_critical
[scheduler] leave rt_enter_critical
[scheduler] enter rt_exit_critical
[scheduler] enter rt_schedule
[scheduler] leave rt_schedule
[scheduler] leave rt_exit_critical
[scheduler] enter rt_enter_critical
[scheduler] leave rt_enter_critical
</pre>



<p>
研究一下，在create init线程的时候，为什么会进入 <code>rt_system_scheduler_init</code> 函数
</p>



<pre class="src src-c">
rt_system_timer_thread_init();
</pre>



<p>
为了看的更加详细些，建议在thread.c里面的每个函数里面也都加入调试信息-&gt;
</p>


<pre class="src src-c">
rt_thread_init();
-&gt;enter rt_thread_create();
-&gt;enter _rt_thread_init();
-&gt;leave _rt_thread_init();
-&gt;leave rt_thread_create();
rt_thread_startup();
-&gt;enter rt_thread_startup();
-&gt;print <span style="color: #8fbc8f; font-style: italic;">"startup a thread: init with priority:10"</span>
</pre>




<p>
然后代码改变了线程的状态
</p>


<pre class="src src-c">
thread-&gt;stat = RT_THREAD_SUSPEND;

rt_thread_resume(thread);
</pre>




<p>
从而导致了
</p>


<pre class="src src-c">
-&gt;enter rt_thread_resume();
-&gt;&#20174;suspend list&#20013;&#31227;&#38500;&#65292;&#28982;&#21518;&#28155;&#21152;&#21040;schedule ready list&#20013;&#21435;
-&gt;enter rt_schedule_insert_thread();
-&gt;leave rt_schedule_insert_thread();
-&gt;leave rt_thread_resume();

-&gt;enter rt_thread_self();
&#22240;&#20026;&#36824;&#27809;&#26377;&#25191;&#34892;&#36807;rt_system_scheduler_start();&#25152;&#20197;&#36825;&#37324;&#19981;&#25191;&#34892;rt_schedule();
-&gt;leave rt_thread_self();

-&gt;leave rt_thread_startup();
</pre>




<p>
在用同样的流程创建完idle线程之后才开始调用 <code>rt_system_scheduler_start</code>
</p>
<p>
在这个函数里面寻找优先级最高，也就是数最小的那个线程，然后把 <code>rt_current_thread</code> 赋值。
</p>
<p>
执行 <code>rt_hw_context_switch_to</code> 函数，进行切换
</p>
<p>
<code>rt_hw_context_switch_to</code> 是个汇编代码，在 <code>context_rvds.S</code> 中
</p>
<p>
里面主要用到了
</p><ul>
<li>
<code>rt_interrupt_to_thread</code>
</li>
<li>
<code>rt_interrupt_from_thread</code>
</li>
<li>
<code>rt_thread_switch_interrupt_flag</code>
</li>
<li>
<code>NVIC_SYSPRI2</code>
</li>
<li>
<code>NVIC_PENDSV_PRI</code>
</li>
<li>
<code>NVIC_INT_CTRL</code>
</li>
<li>
<code>NVIC_PENDSVSET</code>
</li>
</ul>

<p>最后触发了 <code>context_rvds.S</code> 里面的 <code>PendSV_Handler</code> 过程
</p>
<p>
然后，一开始注册的init线程才开始工作，在此之前只有timer线程和idle线程工作。
</p>
<p>
现在，简单的归纳一下：
</p>
<p>
一开始从 <code>rt_applicaton_init()</code> 中注册了init线程，并没有启动。
</p>
<p>
因为这个时候init线程的rt<sub>current</sub><sub>thread还是RT</sub><sub>NULL</sub>
</p>
<p>
然后注册了timer线程和idle线程，也没有启动
</p>
<p>
一直等到 <code>rt_system=scheduler_start()</code> 函数执行，才开始唤醒线程。
</p>
<p>
由于没有定义 <code>RT_USING_TIMER_SOFT</code> 所以timer线程没有被注册！
</p>
</div>

</div>

<div id="outline-container-5" class="outline-2">
<h2 id="sec-5">5 定时器 SysTick </h2>
<div id="text-5">


<p>
现在，回过头来看一下 <code>_rt_thread_init()</code> 这个函数
</p>
<p>
最后有一段
</p>


<pre class="src src-c">
<span style="color: #cccccc; font-style: italic;">/*</span><span style="color: #cccccc; font-style: italic;">init thread timer -&gt; timer.c</span><span style="color: #cccccc; font-style: italic;">*/</span>
rt_timer_init(&amp;(thread-&gt;thread_timer), <span style="color: #cccccc; font-style: italic;">//</span><span style="color: #cccccc; font-style: italic;">&#38745;&#24577;&#23450;&#26102;&#22120;&#23545;&#35937;
</span>              thread-&gt;name,            <span style="color: #cccccc; font-style: italic;">//</span><span style="color: #cccccc; font-style: italic;">&#23450;&#26102;&#22120;&#30340;&#21517;&#23383;
</span>              rt_thread_timeout,       <span style="color: #cccccc; font-style: italic;">//</span><span style="color: #cccccc; font-style: italic;">&#36229;&#26102;&#20989;&#25968;
</span>              thread,                  <span style="color: #cccccc; font-style: italic;">//</span><span style="color: #cccccc; font-style: italic;">&#36229;&#26102;&#20989;&#25968;&#30340;&#21442;&#25968;
</span>              0,                       <span style="color: #cccccc; font-style: italic;">//</span><span style="color: #cccccc; font-style: italic;">&#23450;&#26102;&#22120;&#30340;tick
</span>              RT_TIMER_FLAG_ONE_SHOT); <span style="color: #cccccc; font-style: italic;">//</span><span style="color: #cccccc; font-style: italic;">&#23450;&#26102;&#22120;&#30340;&#26631;&#24535;&#20301;
</span></pre>




<p>
找了很多文件，发现没有一个集中的说明问题的……
</p>
<p>
《Cortex-M4 Technical Reference Manual》
</p>
<p>
4.2 Register summary
</p>
<p>
System control reigsters
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<col align="right"></col><col align="left"></col><col align="left"></col><col align="left"></col><col align="left"></col>
<thead>
<tr><th>Address</th><th>Name</th><th>Type</th><th>Reset</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td>0xE000E010</td><td>STCSR</td><td>RW</td><td>0x00000000</td><td>SysTick Control and Status Register</td></tr>
<tr><td>0xE000E014</td><td>STRVR</td><td>RW</td><td>Unknown</td><td>SysTick Reload Value Register</td></tr>
<tr><td>0xE000E018</td><td>STCVR</td><td>RW clear</td><td>Unkndow</td><td>SysTick Current Value Register</td></tr>
<tr><td>0xE000E01C</td><td>STCR</td><td>RO</td><td>STCALIB</td><td>SysTick Calibration Value Register</td></tr>
</tbody>
</table>


<p>
《STM32F4xxx Cortex-M4 programming manual》
</p>
<p>
4.5 SysTick timer (STK)
</p>
<p>
The processor has a 24-bit system timer, SysTick, that counts down from the reload value to zero, reloads (wraps to) the value in the STK<sub>LOAD</sub> register on the next clock edge, then counts down on subsequent clocks.
</p>
<p>
When the processor is halted for debugging the counter does not decrement.
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<col align="left"></col><col align="left"></col>
<thead>
<tr><th>STK<sub>CTRL</sub> SysTick control and status register</th><th></th></tr>
</thead>
<tbody>
<tr><td>COUNTFLAG</td><td>Returns 1 if timer counted to 0 since last time this was read</td></tr>
<tr><td>CLKSOURCE</td><td>Clock source selection</td></tr>
<tr><td></td><td>0: AHB/8</td></tr>
<tr><td></td><td>1: Processor clock (AHB)</td></tr>
<tr><td>TICKINT</td><td>SysTick exception request enable</td></tr>
<tr><td></td><td>0: Counting down to zero does not assert the SysTick excepton request</td></tr>
<tr><td></td><td>1: Counting down to zero to asserts the SysTick exception request</td></tr>
<tr><td></td><td>Note:Software can use COUNTFLAG to determine if SysTick has ever counted to zero</td></tr>
<tr><td>ENABLE</td><td>Counter Enable</td></tr>
<tr><td></td><td>0: Counter disabled</td></tr>
<tr><td></td><td>1: Counter enabled</td></tr>
</tbody>
</table>

Enables the counter. When ENABLE is set to 1, the counter loads the RELOAD value from the LOAD register and then counts down.

<p>
On reaching 0, it sets the COUNTFLAG to 1 and optionally asserts the SysTick depending on the value of TICKINT. 
</p>
<p>
It then loads the RELOAD value again, and begins counting.  
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<col align="left"></col><col align="left"></col>
<thead>
<tr><th>STK<sub>LOAD</sub></th><th>SysTick reload value register</th></tr>
</thead>
<tbody>
<tr><td>RELOAD</td><td>RELOAD value</td></tr>
<tr><td></td><td>The LOAD register specifies the start value to load into the STK<sub>VAL</sub> register when the counter is enabled</td></tr>
<tr><td></td><td>and when it reaches 0.</td></tr>
</tbody>
</table>


<p>
Calculating the RELOAD value
</p>
<p>
The RELOAD value can be any value in the range 0x00000001-0x00FFFFFF. 
</p>
<p>
A start value of 0 is possible, but has no effect because the SysTick exception request and COUNTFLAG are activated when count from 1 to 0.
</p>
<p>
The RELOAD value is calculated according to its use:
</p>
<ul>
<li>
To generato a multi-shot timer with a period of N processor clock cycles, use a RELOAD value of N-1. For example, if the SysTick interrupt is required every 100 clock pulses, set RELOAD to 99.

</li>
<li>
To deliver a single SysTick interrupt after a delay of N processor clock cycles, use a RELOAD of value N. For example, if a SysTick interrupt is required after 100 clock pulses, set RELOAD to 99.

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<col align="left"></col><col align="left"></col>
<thead>
<tr><th>STK<sub>VAL</sub></th><th>SysTick current value regiser</th></tr>
</thead>
<tbody>
<tr><td>CURRENT</td><td>Current counter value</td></tr>
</tbody>
</table>

</li>
</ul>

<p>The VAL register contains the current value of the SysTick counter.
</p>
<p>
Reads return the current value of the SysTick counter.
</p>
<p>
A write of any value clears the field to 0, and also clears the COUNTFLAG bit in the STK<sub>CTRL</sub><sub>register</sub> to 0.
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<col align="left"></col><col align="left"></col>
<thead>
<tr><th>STK<sub>CALIB</sub></th><th>SysTick calibration value register</th></tr>
</thead>
<tbody>
<tr><td>NOREF</td><td>NOREF flag.</td></tr>
<tr><td></td><td>Reads as zero. Indicates that a separate reference clock is provided. The frequency of this clock is HCLK/8</td></tr>
<tr><td>SKEW</td><td>SKEW falg.</td></tr>
<tr><td></td><td>Indicates whether the TENMS value is exact.</td></tr>
<tr><td></td><td>Reads as one. Calibration value for the 1 ms inexact timing is not knownbecause TENMS is not known.</td></tr>
<tr><td></td><td>This can affect the suitablity of SysTick as a software real time clock.</td></tr>
<tr><td>TENMS</td><td>Calibration value.</td></tr>
<tr><td></td><td>Indicates the calibration value when the SysTick counter run on HCLK max/8 as external clock.</td></tr>
<tr><td></td><td>The value is product denpendent, please refer to the Product Reference Manual, SysTick Calibration Value section.</td></tr>
<tr><td></td><td>When HCLK is programmed at the maximum frequency, the SysTick period is 1ms.</td></tr>
<tr><td></td><td>If calibration information is not known,</td></tr>
<tr><td></td><td>calculate the calibration value required from the frequency of the processor clock or external clock.</td></tr>
</tbody>
</table>


<p>
SysTick design hits and tips
</p>
<p>
The SysTick counter runs on the processor clock.
</p>
<p>
If this clock signal is stopped for low power mode, the SysTick couner stops.
</p>
<p>
Ensure software uses aligned word accesses to access the SysTick registers.
</p>
<p>
The SysTick counter relaod and current value are undefined at reset, the correct initializaton sequence for the SysTick counter is :
</p><ol>
<li>
Program reload value.
</li>
<li>
Clear current value.
</li>
<li>
Program Countrol and Status register.

</li>
</ol>

<p>看完了数据手册，对应的看一下代码 <code>core_cm4.h</code>
</p>



<pre class="src src-c">
<span style="color: #cccccc; font-style: italic;">/* </span><span style="color: #cccccc; font-style: italic;">System Tick Configration
   This function initialises the system tick timer and its interrupt and start the system tick tiemr.
   Counter is in free running mode to generate periodical interrupts.
 </span><span style="color: #cccccc; font-style: italic;">*/</span>
<span style="color: #add8e6; font-weight: bold;">static</span> __INLINE <span style="color: #9acd32; font-weight: bold;">uint32_t</span> <span style="color: #ffff00; font-weight: bold; font-style: italic;">SysTick_Confit</span>(<span style="color: #9acd32; font-weight: bold;">uint32_t</span> <span style="color: #add8e6; font-weight: bold; font-style: italic;">ticks</span>)
{
    <span style="color: #add8e6; font-weight: bold;">if</span> (ticks &gt; SysTick_LOAD_RELOAD_Msk) { <span style="color: #cccccc; font-style: italic;">/* </span><span style="color: #cccccc; font-style: italic;">Reload value impossible </span><span style="color: #cccccc; font-style: italic;">*/</span>
        <span style="color: #add8e6; font-weight: bold;">return</span>(1);
    }
    SysTick-&gt;LOAD = (tick &amp; SysTick_LOAD_RELOAD_Msk) - 1; <span style="color: #cccccc; font-style: italic;">/*</span><span style="color: #cccccc; font-style: italic;">set reload register</span><span style="color: #cccccc; font-style: italic;">*/</span>
    NVIC_SetPriority(SysTick_IRQn, (1&lt;&lt;__NVIC_PRIO_BITS)-1);<span style="color: #cccccc; font-style: italic;">/*</span><span style="color: #cccccc; font-style: italic;">set Priority for Coterx-M0 System Interrupts</span><span style="color: #cccccc; font-style: italic;">*/</span>
    SysTick-&gt;VAL = 0;
    SysTick-&gt;CTRL = SysTick_CTRL_CLKSOURCE_Msk |
                    SysTick_CTRL_TICKINT_Msk   |
                    SysTick_CTRL_ENABLE_Msk; <span style="color: #cccccc; font-style: italic;">/*</span><span style="color: #cccccc; font-style: italic;">Enable SysTick IRQ and SysTick Timer</span><span style="color: #cccccc; font-style: italic;">*/</span>
}
</pre>





<pre class="src src-c">
<span style="color: #cccccc; font-style: italic;">/*</span><span style="color: #cccccc; font-style: italic;">SysTick Reload Register Definitions</span><span style="color: #cccccc; font-style: italic;">*/</span>
<span style="color: #0000cd;">#define</span> <span style="color: #add8e6; font-weight: bold; font-style: italic;">SysTick_LOAD_RELOAD_Pos</span> 0                                     <span style="color: #cccccc; font-style: italic;">/*</span><span style="color: #cccccc; font-style: italic;">SysTick LOAD: RELOAD Position</span><span style="color: #cccccc; font-style: italic;">*/</span>
<span style="color: #0000cd;">#define</span> <span style="color: #add8e6; font-weight: bold; font-style: italic;">SysTick_LOAD_RELOAD_Msk</span> (0xFFFFFFUL&lt;&lt;SysTick_LOAD_RELOAD_Pos) <span style="color: #cccccc; font-style: italic;">/*</span><span style="color: #cccccc; font-style: italic;">SysTick LOAD: RELOAD Mask</span><span style="color: #cccccc; font-style: italic;">*/</span>
</pre>




<p>
基本上做的事情是： 
</p>
<p>
先赋值，设置中断，清零，设置控制位
</p>
<p>
这个 <code>SysTick_IRQn</code> 在stm32f4xx.h里面
</p>
<p>
typedef enum IRQn-&gt; <code>SysTick_IRQn</code> = -1 <i>*Cortex-M4 System Tick Interrupt*</i>
</p>
<p>
然后让我们跟踪一下这个中断吧
</p>
<p>
<code>startup_stm32f4xx.s</code> 里面写到
</p>


<pre class="src src-asm">
<span style="color: #ffff00; font-weight: bold; font-style: italic;">DCD</span> <span style="color: #add8e6; font-weight: bold;">SysTick</span>_Handler

<span style="color: #ffff00; font-weight: bold; font-style: italic;">SysTick_Handler</span> <span style="color: #add8e6; font-weight: bold;">PROC</span>
                <span style="color: #add8e6; font-weight: bold;">EXPORT</span> SysTick_Handler [WEAK]
                <span style="color: #add8e6; font-weight: bold;">B</span>      .
                <span style="color: #add8e6; font-weight: bold;">ENDP</span>
</pre>




<p>
实现在board.c里面
</p>


<pre class="src src-c">
<span style="color: #9acd32; font-weight: bold;">void</span> <span style="color: #ffff00; font-weight: bold; font-style: italic;">SytTick_Handler</span>(<span style="color: #9acd32; font-weight: bold;">void</span>)
{
    rt_interrupt_enter();
    rt_tick_increase();
    rt_interrupt_leave();
}
</pre>





<pre class="src src-c">
<span style="color: #9acd32; font-weight: bold;">void</span> <span style="color: #ffff00; font-weight: bold; font-style: italic;">rt_tick_increase</span>(<span style="color: #9acd32; font-weight: bold;">void</span>)
{
    <span style="color: #add8e6; font-weight: bold;">struct</span> <span style="color: #9acd32; font-weight: bold;">rt_thread</span> *<span style="color: #add8e6; font-weight: bold; font-style: italic;">thread</span>; <span style="color: #cccccc; font-style: italic;">//</span><span style="color: #cccccc; font-style: italic;">&#23450;&#20041;&#19968;&#20010;&#32447;&#31243;&#32467;&#26500;&#20307;
</span>
    ++rt_tick; <span style="color: #cccccc; font-style: italic;">//</span><span style="color: #cccccc; font-style: italic;">&#36825;&#26159;&#19968;&#20010;&#38745;&#24577;&#20840;&#23616;&#21464;&#37327;&#65292;&#24212;&#35813;&#26159;&#29992;&#26469;&#23384;tick&#35745;&#25968;&#30340;
</span>
    thread = tr_thread_self(); <span style="color: #cccccc; font-style: italic;">//</span><span style="color: #cccccc; font-style: italic;">&#33719;&#21462;&#24403;&#21069;&#22312;&#36816;&#34892;&#30340;&#32447;&#31243;
</span>
    -- thread-&gt;remainning_tick; <span style="color: #cccccc; font-style: italic;">//</span><span style="color: #cccccc; font-style: italic;">&#32447;&#31243;&#21097;&#20313;&#26102;&#38388;&#20943;&#23569;
</span>    <span style="color: #add8e6; font-weight: bold;">if</span> (thread-&gt;remaining_tick == 0) { <span style="color: #cccccc; font-style: italic;">//</span><span style="color: #cccccc; font-style: italic;">&#30475;&#30475;&#26159;&#19981;&#26159;&#20943;&#23569;&#21040;&#38646;&#20102;
</span>        thread-&gt;remaining_tick = thread-&gt;init_tick; <span style="color: #cccccc; font-style: italic;">//</span><span style="color: #cccccc; font-style: italic;">&#20934;&#22791;&#37325;&#26032;&#24320;&#22987;
</span>        rt_thread_yield(); <span style="color: #cccccc; font-style: italic;">//</span><span style="color: #cccccc; font-style: italic;">&#20027;&#21160;&#35753;&#20986;CPU
</span>    }
    rt_timer_check(); <span style="color: #cccccc; font-style: italic;">//</span><span style="color: #cccccc; font-style: italic;">timer.c &#26816;&#26597;timer list&#65292;&#22914;&#26524;&#19968;&#20010;&#36229;&#26102;&#20107;&#20214;&#21457;&#29983;&#65292;&#30456;&#20851;&#30340;&#36229;&#26102;&#20989;&#25968;&#23558;&#20250;&#34987;&#35843;&#29992;
</span>                      <span style="color: #cccccc; font-style: italic;">// </span><span style="color: #cccccc; font-style: italic;">&#36825;&#20010;&#20989;&#25968;&#24212;&#35813;&#22312;&#25805;&#20316;&#31995;&#32479;&#26102;&#38388;&#20013;&#26029;&#20869;&#34987;&#35843;&#29992;                                                           
</span>}
</pre>




<p>
timer.c
</p>


<pre class="src src-c">
<span style="color: #9acd32; font-weight: bold;">void</span> <span style="color: #ffff00; font-weight: bold; font-style: italic;">rt_timer_check</span>(<span style="color: #9acd32; font-weight: bold;">void</span>)
{
    <span style="color: #add8e6; font-weight: bold;">struct</span> <span style="color: #9acd32; font-weight: bold;">rt_timer</span> *<span style="color: #add8e6; font-weight: bold; font-style: italic;">t</span>;
    <span style="color: #9acd32; font-weight: bold;">rt_tick_t</span> <span style="color: #add8e6; font-weight: bold; font-style: italic;">current_tick</span>;
    <span style="color: #add8e6; font-weight: bold;">register</span> <span style="color: #9acd32; font-weight: bold;">rt_base_t</span> <span style="color: #add8e6; font-weight: bold; font-style: italic;">level</span>;

    current_tick = rt_tick_get();

    <span style="color: #cccccc; font-style: italic;">/*</span><span style="color: #cccccc; font-style: italic;">disable interrupt</span><span style="color: #cccccc; font-style: italic;">*/</span>
    level = rt_hw_interrupt_disable();

    <span style="color: #add8e6; font-weight: bold;">while</span>(!rt_list_isempty(&amp;rt_timer_list)) {
        t = rt_list_entry(rt_timer_list.next, <span style="color: #add8e6; font-weight: bold;">struct</span> <span style="color: #9acd32; font-weight: bold;">rt_timer</span>, list);

        <span style="color: #cccccc; font-style: italic;">/*</span><span style="color: #cccccc; font-style: italic;">
            It supposes that the new tick shall less than the half duration ofo tick max.
        </span><span style="color: #cccccc; font-style: italic;">*/</span>
        <span style="color: #add8e6; font-weight: bold;">if</span> ((current_tick - t-&gt;timeout_tick) &lt; RT_TICK_MAX/2) {
            RT_OBJECT_HOOK_CALL(rt_timer_timeout_hook, (t));

            <span style="color: #cccccc; font-style: italic;">/*</span><span style="color: #cccccc; font-style: italic;">remove timer from timer list firstly</span><span style="color: #cccccc; font-style: italic;">*/</span>
            rt_list_remove(&amp;(t-&gt;list));

            <span style="color: #cccccc; font-style: italic;">/*</span><span style="color: #cccccc; font-style: italic;">call timeout fucntion </span><span style="color: #cccccc; font-style: italic;">*/</span>
            t-&gt;timeout_func(t-&gt;parameter);

            <span style="color: #cccccc; font-style: italic;">/*</span><span style="color: #cccccc; font-style: italic;">re-get tick</span><span style="color: #cccccc; font-style: italic;">*/</span>
            current_tick = rt_tick_get();
            
            <span style="color: #add8e6; font-weight: bold;">if</span> ((t-&gt;parent.flag &amp; RT_TIMER_FLAG_PERIODIC) &amp;&amp; 
                (t-&gt;parent.flag &amp; RT_TIMER_FLAG_ACTIVATED)) {
                <span style="color: #cccccc; font-style: italic;">/*</span><span style="color: #cccccc; font-style: italic;">start it</span><span style="color: #cccccc; font-style: italic;">*/</span>
                t-&gt;parent.flag &amp;= ~RT_TIMER_FLAG_ACTIVATED;
                rt_timer_start(t);
            } <span style="color: #add8e6; font-weight: bold;">else</span> {
                <span style="color: #cccccc; font-style: italic;">/*</span><span style="color: #cccccc; font-style: italic;">stop timer</span><span style="color: #cccccc; font-style: italic;">*/</span>
                t-&gt;parent.flag &amp;= ~RT_TIMER_FLAG_ACTIVATED;
            }
        } <span style="color: #add8e6; font-weight: bold;">else</span> 
            <span style="color: #add8e6; font-weight: bold;">break</span>;
    }
    
    <span style="color: #cccccc; font-style: italic;">/* </span><span style="color: #cccccc; font-style: italic;">enable interrupt </span><span style="color: #cccccc; font-style: italic;">*/</span>
    rt_hw_interrupt_enable(level);
}
</pre>




<p>
牵一发而动全身，现在又从硬件寄存器的控制转移到该死的链表操作里面去了。
</p>
<p>
现在模糊的理解了定时器是怎么集成到操作系统里面去的。
</p>
<p>
在每个线程被初始化的时候，都会产生一个以线程名字命名的定时器。
</p>
<p>
而系统的SysTick定时器是已经在运行中的了，每隔一定的时间就会产生硬件中断，然后执行中断服务程序，遍历所有的定时器链表，修改当前线程的timeout值。
</p>
<p>
而我们知道，线程的调度是通过优先级和时间片共同的作用来的。因此……是不是我们可以先看一下优先级所起到的作用。
</p>
</div>

</div>

<div id="outline-container-6" class="outline-2">
<h2 id="sec-6">6 线程 优先级 </h2>
<div id="text-6">


<p>
线程的优先级被定义在rtdef.h中
</p>


<pre class="src src-c">
<span style="color: #cccccc; font-style: italic;">/*</span><span style="color: #cccccc; font-style: italic;">thread state definitions</span><span style="color: #cccccc; font-style: italic;">*/</span>
<span style="color: #0000cd;">#define</span> <span style="color: #add8e6; font-weight: bold; font-style: italic;">RT_THREAD_INIT</span>        0x00                 <span style="color: #cccccc; font-style: italic;">// </span><span style="color: #cccccc; font-style: italic;">&#21021;&#22987;&#29366;&#24577; &#32447;&#31243;&#19981;&#21442;&#19982;&#35843;&#24230;
</span><span style="color: #0000cd;">#define</span> <span style="color: #add8e6; font-weight: bold; font-style: italic;">RT_THREAD_READY</span>       0x01                 <span style="color: #cccccc; font-style: italic;">// </span><span style="color: #cccccc; font-style: italic;">&#23601;&#32490;&#29366;&#24577; 
</span><span style="color: #0000cd;">#define</span> <span style="color: #add8e6; font-weight: bold; font-style: italic;">RT_THREAD_SUSPEND</span>     0x02                 <span style="color: #cccccc; font-style: italic;">// </span><span style="color: #cccccc; font-style: italic;">&#25346;&#36215;&#29366;&#24577; &#32447;&#31243;&#19981;&#21442;&#19982;&#35843;&#24230; 
</span><span style="color: #0000cd;">#define</span> <span style="color: #add8e6; font-weight: bold; font-style: italic;">RT_THREAD_RUNNING</span>     0x03                 <span style="color: #cccccc; font-style: italic;">// </span><span style="color: #cccccc; font-style: italic;">&#36816;&#34892;&#29366;&#24577;
</span><span style="color: #0000cd;">#define</span> <span style="color: #add8e6; font-weight: bold; font-style: italic;">RT_THREAD_BLOCK</span>       RT_THREAD_SUSPEND    <span style="color: #cccccc; font-style: italic;">// </span><span style="color: #cccccc; font-style: italic;">&#38459;&#22622;&#29366;&#24577; &#32447;&#31243;&#19981;&#21442;&#19982;&#35843;&#24230;
</span><span style="color: #0000cd;">#define</span> <span style="color: #add8e6; font-weight: bold; font-style: italic;">RT_THREAD_CLOSE</span>       0x04                 <span style="color: #cccccc; font-style: italic;">// </span><span style="color: #cccccc; font-style: italic;">&#20851;&#38381;&#29366;&#24577; &#32447;&#31243;&#19981;&#21442;&#19982;&#35843;&#24230;
</span></pre>





</div>

<div id="outline-container-6.1" class="outline-3">
<h3 id="sec-6.1">6.1 <code>RT_THREAD_INIT</code> </h3>
<div id="text-6.1">

<p>只有在 <code>_rt_thread_init</code> 函数里面将thread-&gt;stat赋值为 <code>RT_THREAD_INIT</code>
</p>
</div>

</div>

<div id="outline-container-6.2" class="outline-3">
<h3 id="sec-6.2">6.2 <code>RT_THREAD_READY</code> </h3>
<div id="text-6.2">

<p>在 <code>rt_schedule_insert_thread</code> 函数中改变状态
</p>
</div>

</div>

<div id="outline-container-6.3" class="outline-3">
<h3 id="sec-6.3">6.3 <code>RT_THREAD_SUSPEND</code> </h3>
<div id="text-6.3">

<p><code>rt_thread_startup</code> 函数将挂起线程
</p>
<p>
<code>rt_thread_suspend</code> 函数会挂起线程
</p>
</div>

</div>

<div id="outline-container-6.4" class="outline-3">
<h3 id="sec-6.4">6.4 <code>RT_THREAD_RUNNING</code> </h3>
<div id="text-6.4">

<p>都没搜到哪里用到了
</p>
</div>

</div>

<div id="outline-container-6.5" class="outline-3">
<h3 id="sec-6.5">6.5 <code>RT_THREAD_BLOCK</code> </h3>
<div id="text-6.5">

<p>也没有地方用到
</p>
</div>

</div>

<div id="outline-container-6.6" class="outline-3">
<h3 id="sec-6.6">6.6 <code>RT_THREAD_CLOSE</code> </h3>
<div id="text-6.6">

<p><code>rt_thread_exit</code> 函数会关闭线程
</p>
<p>
<code>rt_thread_detach</code> 函数会关闭线程
</p>
<p>
<code>rt_thread_delete</code> 函数会关闭线程
</p>
</div>

</div>

<div id="outline-container-6.7" class="outline-3">
<h3 id="sec-6.7">6.7 kernel如何找到当前优先级最高的线程的 </h3>
<div id="text-6.7">


<p>
blog.csdn.net/prife/articale/details/7077120 文章中 Prife写的非常的详尽和清楚明白
</p>
<p>
主要是进行了位图调度算法分析
</p>
<p>
先说白了就是一个哈希表+双向链表的结构，不过这个哈希表是个位图，也就是个二位数组，映射起来很方便。
</p>
<p>
rt-thread的调度算法是基于优先级和时间片的，时间片部分前面大概分析了以下，不过还不是很清晰。
</p>
<p>
优先级这部分，通过上面的文章介绍，倒是很清晰了。很感谢Prife开放自己的思想。
</p>
<p>
这个问题可以这么描述：
</p>
<p>
现在有一堆优先级不同的线程，优先级是一个数，这个数越小表示这个线程的优先级越高，现在要用一种简单的方法来找出来这一堆线程里面谁的优先级最高。
</p>
<p>
现在先要定义一个数组来表示优先级
</p>


<pre class="src src-c">
<span style="color: #9acd32; font-weight: bold;">rt_list_t</span> <span style="color: #add8e6; font-weight: bold; font-style: italic;">rt_thread_priority_table</span>[RT_THREAD_PRIORITY_MAX];
</pre>



<p>
这其中 <code>RT_THREAD_PRIORITY_MAX</code> = 256
</p>
<p>
我们的目的在于找出当前最高的优先级是多少来，然后根据 <code>rt_thread_priority_table[最高优先级]</code> 来找到对应的进程。
</p>
<p>
实际的代码是
</p>


<pre class="src src-c">
to_thread = rt_list_entry(rt_thread_priority_table[highest_ready_priority].next, xxxx);
</pre>



<p>
因此，如何确定 <code>hightest_ready_priorit</code> 就关键了
</p>
<p>
这里存在这么一个问题，如果使用for循环是肯定可以找到的，不过时间消耗没有办法确定，我们需要的是一个时间消耗恒定的算法。
</p>
<p>
因此，就想，不就是256个优先级么，当前这个优先级上要不有ready进程，要不没有。
</p>
<p>
因此，可以用一个256bits的数来表示，bit为1就表示这一个级别的优先级上有ready进程，否则，就是空的。
</p>
<p>
从C语言的角度来看，定义一个数组来表示比较合适
</p>


<pre class="src src-c">
<span style="color: #9acd32; font-weight: bold;">rt_uint8_t</span> <span style="color: #add8e6; font-weight: bold; font-style: italic;">rt_thread_ready_table</span>[32];
</pre>




<p>
为什么是uint8也就是8位的呢，因为，8位的的确是比较好算，好处理。
</p>
<p>
这样相当于给256个bit分了32组，每组8个优先级。
</p>
<p>
现在，我们就单独的只看8个优先级，这8个bit。
</p>
<p>
8个bit可以形成一个byte。它的取值范围是0x00到0xFF。
</p>
<p>
为什么这么说，因为，每当新建一个进程的时候，都会赋予它一个优先级，对应的，这个byte对应的位就要置1。
</p>
<p>
比如，现在有A,B,C三个进程，优先级分别为1，3，4，则，这个byte=0b00011010=26=0x1a。
</p>
<p>
这也是为什么我们用8位来解释问题，因为32位所代表的数实在是太大了，2<sup>32</sup>=4G，没法表示～(这里说的是 <code>rt_thread_ready_priority_group</code> 这个32位的数)
</p>
<p>
这32位表示了 <code>rt_thread_ready_table</code> 的32个组。这样考虑的，以8位为单位进行最小位图的展开，这样相当于形成了一个二级的映射关系。
</p>
<p>
256bit-&mdash;&gt;32group-&mdash;&gt;8bit位图
</p>
<p>
把这0x00~0xFF表示成一个数
</p>
<p>
那么，这8位优先级中找到最高的优先级的问题，就变成了，这个数里面最低位为1的问题。
</p>
<p>
是这么理解的：
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<col align="right"></col><col align="right"></col><col align="right"></col><col align="left"></col><col align="left"></col><col align="left"></col><col align="left"></col><col align="left"></col><col align="left"></col><col align="left"></col>
<thead>
<tr><th>bit7</th><th>bit6</th><th>bit5</th><th>bit4</th><th>bit3</th><th>bit2</th><th>bit1</th><th>bit0</th><th>十进制</th><th>最高优先级</th></tr>
</thead>
<tbody>
<tr><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr>
<tr><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>1</td><td>0</td></tr>
<tr><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>2</td><td>1</td></tr>
<tr><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>1</td><td>3</td><td>0</td></tr>
<tr><td>..</td><td>..</td><td>..</td><td>..</td><td>..</td><td>..</td><td>..</td><td>..</td><td>..</td><td>..</td></tr>
<tr><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>255</td><td>0</td></tr>
</tbody>
</table>


<p>
研究一下上表，会发现，可以事先确定出来，最高优先级是几。
</p>
<p>
因此可以得到一个数组
</p>


<pre class="src src-c">
<span style="color: #add8e6; font-weight: bold;">const</span> <span style="color: #9acd32; font-weight: bold;">rt_uint8_t</span> <span style="color: #add8e6; font-weight: bold; font-style: italic;">rt_lowest_bitmap</span>[] =
{
    <span style="color: #cccccc; font-style: italic;">/* </span><span style="color: #cccccc; font-style: italic;">00 </span><span style="color: #cccccc; font-style: italic;">*/</span> 0, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
    <span style="color: #cccccc; font-style: italic;">/* </span><span style="color: #cccccc; font-style: italic;">10 </span><span style="color: #cccccc; font-style: italic;">*/</span> 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
    <span style="color: #cccccc; font-style: italic;">/* </span><span style="color: #cccccc; font-style: italic;">20 </span><span style="color: #cccccc; font-style: italic;">*/</span> 5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
    <span style="color: #cccccc; font-style: italic;">/* </span><span style="color: #cccccc; font-style: italic;">30 </span><span style="color: #cccccc; font-style: italic;">*/</span> 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
    <span style="color: #cccccc; font-style: italic;">/* </span><span style="color: #cccccc; font-style: italic;">40 </span><span style="color: #cccccc; font-style: italic;">*/</span> 6, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
    <span style="color: #cccccc; font-style: italic;">/* </span><span style="color: #cccccc; font-style: italic;">50 </span><span style="color: #cccccc; font-style: italic;">*/</span> 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
    <span style="color: #cccccc; font-style: italic;">/* </span><span style="color: #cccccc; font-style: italic;">60 </span><span style="color: #cccccc; font-style: italic;">*/</span> 5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
    <span style="color: #cccccc; font-style: italic;">/* </span><span style="color: #cccccc; font-style: italic;">70 </span><span style="color: #cccccc; font-style: italic;">*/</span> 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
    <span style="color: #cccccc; font-style: italic;">/* </span><span style="color: #cccccc; font-style: italic;">80 </span><span style="color: #cccccc; font-style: italic;">*/</span> 7, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
    <span style="color: #cccccc; font-style: italic;">/* </span><span style="color: #cccccc; font-style: italic;">90 </span><span style="color: #cccccc; font-style: italic;">*/</span> 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
    <span style="color: #cccccc; font-style: italic;">/* </span><span style="color: #cccccc; font-style: italic;">A0 </span><span style="color: #cccccc; font-style: italic;">*/</span> 5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
    <span style="color: #cccccc; font-style: italic;">/* </span><span style="color: #cccccc; font-style: italic;">B0 </span><span style="color: #cccccc; font-style: italic;">*/</span> 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
    <span style="color: #cccccc; font-style: italic;">/* </span><span style="color: #cccccc; font-style: italic;">C0 </span><span style="color: #cccccc; font-style: italic;">*/</span> 6, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
    <span style="color: #cccccc; font-style: italic;">/* </span><span style="color: #cccccc; font-style: italic;">D0 </span><span style="color: #cccccc; font-style: italic;">*/</span> 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
    <span style="color: #cccccc; font-style: italic;">/* </span><span style="color: #cccccc; font-style: italic;">E0 </span><span style="color: #cccccc; font-style: italic;">*/</span> 5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
    <span style="color: #cccccc; font-style: italic;">/* </span><span style="color: #cccccc; font-style: italic;">F0 </span><span style="color: #cccccc; font-style: italic;">*/</span> 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0
};
</pre>




<p>
那，我们看看，进程在创建的时候，优先级是怎么来影响个个变量的呢
</p>



<pre class="src src-c">
<span style="color: #cccccc; font-style: italic;">// </span><span style="color: #cccccc; font-style: italic;">&#19968;&#24320;&#22987;&#30340;&#26102;&#20505;&#65292;&#35201;&#29992;&#21040;thread&#32467;&#26500;&#20307;
</span>thread-&gt;init_priority = priority;
<span style="color: #cccccc; font-style: italic;">// </span><span style="color: #cccccc; font-style: italic;">&#22312;starup&#20989;&#25968;&#37324;&#38754;&#65292;&#36716;&#25442;&#20248;&#20808;&#32423;&#65292;&#32431;&#25968;&#23398;
</span>thread-&gt;number = thread-&gt;current_priority &gt;&gt; 3; <span style="color: #cccccc; font-style: italic;">//</span><span style="color: #cccccc; font-style: italic;">&#30456;&#24403;&#20110;prioroity/8&#21462;&#24471;&#33853;&#22312;&#21738;&#19968;&#20010;&#32452;&#37324;&#38754;
</span>thread-&gt;number_mask = 1L &lt;&lt; thread_number; 
thread-&gt;high_mask = 1L &lt;&lt; (thread-&gt;current_priority &amp; 0x07); <span style="color: #cccccc; font-style: italic;">//</span><span style="color: #cccccc; font-style: italic;">&#30456;&#24403;&#20110;priority%8&#65292;&#20313;&#25968;&#65292;&#21462;&#30340;&#36825;&#19968;&#20010;&#32452;&#20013;&#65292;8bit&#20013;&#30340;&#31532;&#20960;&#20301;
</span><span style="color: #cccccc; font-style: italic;">// </span><span style="color: #cccccc; font-style: italic;">&#32622;&#19968;&#30340;&#30446;&#30340;&#22312;&#20110;&#26041;&#20415;&#20301;&#25805;&#20316;
</span><span style="color: #cccccc; font-style: italic;">// </span><span style="color: #cccccc; font-style: italic;">insert&#36827;&#31243;&#30340;&#26102;&#20505;&#32622;&#20301;
</span>rt_thread_ready_table[thread-&gt;number] |= thread-&gt;high_mask; <span style="color: #cccccc; font-style: italic;">// </span><span style="color: #cccccc; font-style: italic;">&#23545;&#24212;&#32452;&#20013;&#30340;&#23545;&#24212;&#20301;&#65292;&#32622;&#19968;
</span>rt_thread_ready_priority_group |= thread-&gt;number_mask; <span style="color: #cccccc; font-style: italic;">// </span><span style="color: #cccccc; font-style: italic;">&#23545;&#24212;&#32452;&#20013;&#30340;&#26631;&#35760;&#65292;&#32622;&#19968;
</span></pre>




<p>
现在可以看出来， <code>rt_thread_ready_table[]</code> 是对256个优先级的一一映射。
</p>
<p>
而 <code>rt_thread_ready_priority_group</code> 是对这个表的一个抽象，分组。
</p>
<p>
看到这儿，我觉得我可以理解schedule的代码了
</p>
<p>
256位的十六进制就是0xFFFF FFFF。
</p>
<p>
主要使用 <code>rt_thread_ready_priority_group</code> 来进行操作，每次比较8位，相当于把32个组又分成了8x4份来进行比较。
</p>
<p>
因此，会有
</p>


<pre class="src src-c">
rt_thread_ready_priority_group &amp; 0x000000FF
rt_thread_ready_priority_group &amp; 0x0000FF00
rt_thread_ready_priority_group &amp; 0x00FF0000
rt_thread_ready_priority_group &amp; 0xFF000000
</pre>



<p>
这样的代码比较，主要是比较出来，哪8位的里面有1的存在，而且是从低位到高位比较的，这样，也遵循了低位表示高优先级的原则
</p>
<p>
假设0xff的就中了，那么
</p>


<pre class="src src-c">
number = rt_lowest_bitmap[rt_thread_ready_priority_group &amp; 0xff];
</pre>



<p>
就表示了，在这8位中，查表，得到了，最低优先级的位数，赋值给number。此时number表示，在32个组中，第几个组里面有最后的结果。
</p>
<p>
然后这个组里的第几位要通过
</p>


<pre class="src src-c">
rt_lowest_bitmap[rt_thread_ready_table[number]]; 
</pre>



<p>
来查表，找出了，具体的第几位。
</p>
<p>
最后再把它们拼接起来，所以就有了
</p>


<pre class="src src-c">
highest_ready_priority = (number &lt;&lt; 3) + rt_lowest_bitmap[rt_thread_ready_table[number]]
</pre>




<p>
整个相当于查了四次表
</p><ul>
<li>
第一次： <code>rt_thread_ready_priority_group</code> 中第几组8位中存在1
</li>
<li>
第二次： 这个8位的组中，最低位是1的是第几位,代表了32个组中第几个组中有最高优先级
</li>
<li>
第三次： <code>rt_thread_ready_table</code> 中这一组中的内容取出来
</li>
<li>
第四次： 再用一边 <code>rt_lowest_bitmap</code> 的查表，确认这一组中第几位是1，表示了最高优先级
</li>
</ul>

<p>最后把“组信息“和“组内的位信息“还原回表示整个256位中第几位的数值
</p>
<p>
一个先抽象运算再还原结果的过程。其中这个 <code>rt_lowest_bitmap</code> 的位图被使用了两次，算法是一样的，其意义是不一样的。
</p>
<p>
虽然都是为了找8位中最低位为1的位数，只是，这个位数所表示的含义是不一样的。
</p>
<p>
通过这一系列的折腾，就找到了当前最高的优先级的进程，而且是在ready队列里面的，接下来就准备调用它了。
</p>
<p>
不在ready队列里面的是不会被调度的。
</p></div>
</div>
</div>
<div id="postamble"><p class="author"> Author: Wizard.Yang
<a href="mailto:xblandy@gmail.com">&lt;xblandy@gmail.com&gt;</a>
</p>
<p class="date"> Date: 2012-09-10 14:10:12 CST</p>
</div></body>
</html>
